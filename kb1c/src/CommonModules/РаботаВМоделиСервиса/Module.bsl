///////////////////////////////////////////////////////////////////////////////////
// РаботаВМоделиСервиса.
//
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Возвращает имя общего реквизита, который является разделителем основных данных.
//
// Возвращаемое значение: Строка.
//
Функция РазделительОсновныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Имя;
	
КонецФункции

// Возвращает имя общего реквизита, который является разделителем вспомогательных данных.
//
// Возвращаемое значение: Строка.
//
Функция РазделительВспомогательныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные.Имя;
	
КонецФункции

// Очищает все параметры сеанса, кроме связанных с общим 
// реквизитом ОбластьДанных.
//
Процедура ОчиститьВсеПараметрыСеансаКромеРазделителей() Экспорт
	
	ОбщегоНазначения.ОчиститьПараметрыСеанса(, "ОбластьДанныхЗначение,ОбластьДанныхИспользование");
	
КонецПроцедуры

// Устанавливает блокировку области данных
// 
// Параметры: 
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// РазделяемаяБлокировка - Булево - установить разделяемую блокировку
// вместо исключительной.
// 
Процедура ЗаблокироватьТекущуюОбластьДанных(Знач ПроверитьОтсутствиеДругихСеансов = Ложь, Знач РазделяемаяБлокировка = Ложь) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		ВызватьИсключение(НСтр("ru = 'Блокировка области может быть установлена только при включенном использовании разделителей'"));
	КонецЕсли;
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбщегоНазначения.ЗначениеРазделителяСеанса()));
	
	КоличествоПопыток = 5;
	ТекущаяПопытка = 0;
	Пока Истина Цикл
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
			Прервать;
		Исключение
			ТекущаяПопытка = ТекущаяПопытка + 1;
			
			Если ТекущаяПопытка = КоличествоПопыток Тогда
				ШаблонКомментария = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКомментария, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Блокировка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстКомментария);
					
				ШаблонТекста = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, 
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
					
				ВызватьИсключение(Текст);
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Если СтандартныеПодсистемыПовтИсп.ЭтоПлатформа83БезРежимаСовместимости() И НЕ РазделяемаяБлокировка Тогда
		УстановитьМонопольныйРежим(Истина);
		Возврат;
	КонецЕсли;
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	Если РазделяемаяБлокировка Тогда
		РежимБлокировки = РежимБлокировкиДанных.Разделяемый;
	Иначе
		РежимБлокировки = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	Для Каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение;
		
		ПространствоБлокировки = ПолноеИмяОбъектаМетаданных;
		
		Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных) Тогда
			
			БлокироватьНаборы = Истина;
			Если ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных) Тогда
				ОбъектМетаданныхОбласти = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				Если ОбъектМетаданныхОбласти.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
					БлокироватьНаборы = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если БлокироватьНаборы Тогда
				ПространствоБлокировки = ПространствоБлокировки + ".НаборЗаписей";
			КонецЕсли;
			
		ИначеЕсли ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
			
			ПространствоБлокировки = ПространствоБлокировки + ".Записи";
			
		ИначеЕсли ЭтоПолноеИмяЖурналаДокументов(ПолноеИмяОбъектаМетаданных) ИЛИ
				ЭтоПолноеИмяПеречисления(ПолноеИмяОбъектаМетаданных) ИЛИ
				ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) ИЛИ
				ЭтоПолноеИмяРегламентногоЗадания(ПолноеИмяОбъектаМетаданных) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
		ЭлементБлокировки.Режим = РежимБлокировки;
		
	КонецЦикла;
	
	Блокировка.Заблокировать();
	
	Если ПроверитьОтсутствиеДругихСеансов Тогда
		Для каждого Сеанс Из ПолучитьСеансыИнформационнойБазы() Цикл
			Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
				Продолжить;
			КонецЕсли;
			
			КлиентскиеПриложения = Новый Массив;
			КлиентскиеПриложения.Добавить(ВРег("1CV8"));
			КлиентскиеПриложения.Добавить(ВРег("1CV8C"));
			КлиентскиеПриложения.Добавить(ВРег("WebClient"));
			КлиентскиеПриложения.Добавить(ВРег("COMConnection"));
			КлиентскиеПриложения.Добавить(ВРег("WSConnection"));
			КлиентскиеПриложения.Добавить(ВРег("BackgroundJob"));
			Если КлиентскиеПриложения.Найти(ВРег(Сеанс.ИмяПриложения)) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Есть другие пользователи
			ВызватьИсключение(НСтр("ru = 'Ошибка разделенного доступа к базе данных'"));
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Снимает исключительную блокировку области с текущей области данных
//
Процедура РазблокироватьТекущуюОбластьДанных() Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбщегоНазначения.ЗначениеРазделителяСеанса()));
		
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	Если СтандартныеПодсистемыПовтИсп.ЭтоПлатформа83БезРежимаСовместимости() Тогда
		УстановитьМонопольныйРежим(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Проверяет блокировку области данных.
//
// Параметры:
//  ОбластьДанных -  Число - значение разделителя области данных, 
//   блокировку которой требуется проверить
//
// Возвращаемое значение:
// Булево - Истина область данных заблокирована, иначе нет
//
Функция ОбластьДанныхЗаблокирована(Знач ОбластьДанных) Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Ключ);
	Исключение
		Возврат Истина;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	Возврат Ложь;
	
КонецФункции

// Подготавливает область данных к использованию. Запускает
// процедура обновления ИБ, при необходимости заполняет демонстрационными
// данными, устанавливает новый статус в регистре ОбластиДанных.
// 
// Параметры: 
// ОбластьДанных - Тип значения разделителя - значение разделителя
// области данных, которую необходимо подготовить к использованию.
// 
Процедура ПодготовитьОбластьДанныхКИспользованию(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 Знач Вариант = Неопределено) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.Новая);
		
		ПользователиСлужебный.АвторизоватьТекущегоПользователя();
		
		СообщениеОбОшибке = "";
		Если Не ЗначениеЗаполнено(Вариант) Тогда
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(ОбластьДанных, ИДФайлаВыгрузки, 
				СообщениеОбОшибке);
			
		Иначе
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(ОбластьДанных, ИДФайлаВыгрузки, 
				Вариант, СообщениеОбОшибке);
				
		КонецЕсли;
		
		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, РезультатПодготовки, СообщениеОбОшибке);

	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);

КонецПроцедуры

// Копирует данные области данных в другую область данных.
// 
// Параметры: 
// ОбластьИсточник - Тип значения разделителя - значение разделителя
// области данных - источника данных
// ОбластьПриемник - Тип значения разделителя - значение разделителя
// области данных - приемника данных
// 
Процедура СкопироватьДанныеОбласти(Знач ОбластьИсточник, Знач ОбластьПриемник) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьИсточник);
	
	ИмяФайлаВыгрузки = Неопределено;
	
	НачатьТранзакцию();
	Попытка
		ЗаблокироватьТекущуюОбластьДанных(, Истина);
		ИмяФайлаВыгрузки = ВыгрузкаЗагрузкаДанных.ВыгрузитьТекущуюОбластьВАрхив();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Копирование области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ИмяФайлаВыгрузки <> Неопределено Тогда
			Попытка
				УдалитьФайлы(ИмяФайлаВыгрузки);
			Исключение
			КонецПопытки;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(, ОбластьПриемник);
	
	Попытка
		ОбщегоНазначения.ЗаблокироватьИБ();
		ВыгрузкаЗагрузкаДанных.ЗагрузитьТекущуюОбластьИзАрхива(ИмяФайлаВыгрузки);
		ОбщегоНазначения.РазблокироватьИБ();
	Исключение
		ОбщегоНазначения.РазблокироватьИБ();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Копирование области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

// Удаляет все данные области данных, кроме предопределенных, устанавливает для области данных
//  статус Удалена, отправляет в менеджер сервиса сообщение с информацией об изменении статуса
//  области. После этого область данных будет непригодна к использованию.
//
// Если нужно удалить все данные области без изменения ее статуса и с сохранением возможности
//  дальнейшего использования области, необходимо использовать процедуру ОчиститьДанныеОбласти().
//
// Параметры: 
//  ОбластьДанных - Число(7,0) - значение разделителя области данных которую требуется очистить,
//   При вызове процедуры разделение данных уже должно быть переключено в эту область.
//  УдалитьПользователей - Булево - флаг необходимости удаления пользователей информационной
//    базы для данной области данных.
//
Процедура ОчиститьОбластьДанных(Знач ОбластьДанных, Знач УдалитьПользователей = Истина) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.КУдалению);
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУдаленииОбластиДанных");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриУдаленииОбластиДанных(ОбластьДанных);
		КонецЦикла;
		
		РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных(ОбластьДанных);
		
		ОчиститьДанныеОбласти(УдалитьПользователей); // Вызываем очистку
		
		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, "ОбластьУдалена", "");
		
	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);
	
КонецПроцедуры

// Удаляет все разделенные данные из текущей области данных (в т.ч. при выключенном
//  разделении по областям данных), кроме переопределенных.
//
// Параметры:
//  УдалитьПользователей - Булево, флаг необходимости удаления пользователей
//    информационной базы.
//
Процедура ОчиститьДанныеОбласти(Знач УдалитьПользователей) Экспорт
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	ИсключенияОчистки = Новый Массив();
	ИсключенияОчистки.Добавить(Метаданные.РегистрыСведений.ОбластиДанных.ПолноеИмя());
	
	Для Каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение;
		
		Если ИсключенияОчистки.Найти(ПолноеИмяОбъектаМетаданных) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПолноеИмяКонстанты(ПолноеИмяОбъектаМетаданных) Тогда
			
			ОбъектМетаданныхОбласти = Метаданные.Константы.Найти(ОписаниеОбъектаМетаданных.Имя);
			МенеджерЗначения = Константы[ОписаниеОбъектаМетаданных.Имя].СоздатьМенеджерЗначения();
			МенеджерЗначения.ОбменДанными.Загрузка = Истина;
			МенеджерЗначения.Значение = ОбъектМетаданныхОбласти.Тип.ПривестиЗначение();
			МенеджерЗначения.Записать();
			
		ИначеЕсли ЭтоПолноеИмяОбъектаСсылочногоТипа(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоПланОбмена = ЭтоПолноеИмяПланаОбмена(ПолноеИмяОбъектаМетаданных);
			
			Запрос = Новый Запрос;
			Запрос.Текст =
			"ВЫБРАТЬ
			|	_XMLВыгрузка_Таблица.Ссылка КАК Ссылка
			|ИЗ
			|	" + ПолноеИмяОбъектаМетаданных + " КАК _XMLВыгрузка_Таблица";
			
			Если ЭтоПолноеИмяСправочника(ПолноеИмяОбъектаМетаданных) ИЛИ
					ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмяОбъектаМетаданных) ИЛИ
					ЭтоПолноеИмяПланаСчетов(ПолноеИмяОбъектаМетаданных) ИЛИ
					ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмяОбъектаМетаданных) Тогда
				
				Запрос.Текст = Запрос.Текст + "
				|ГДЕ
				|	_XMLВыгрузка_Таблица.Предопределенный = ЛОЖЬ";
				
			ИначеЕсли ЭтоПланОбмена Тогда
				
				Запрос.Текст = Запрос.Текст + "
				|ГДЕ
				|	_XMLВыгрузка_Таблица.Ссылка <> &ЭтотУзел";
				Запрос.УстановитьПараметр("ЭтотУзел", ПланыОбмена[ОписаниеОбъектаМетаданных.Имя].ЭтотУзел());
				
			КонецЕсли;
			
			РезультатЗапроса = Запрос.Выполнить();
			Выборка = РезультатЗапроса.Выбрать();
			Пока Выборка.Следующий() Цикл
				Удаление = Новый УдалениеОбъекта(Выборка.Ссылка);
				Удаление.ОбменДанными.Загрузка = Истина;
				Удаление.Записать();
			КонецЦикла;
			
		ИначеЕсли ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоРегистрСведений = ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных);
			Если ЭтоРегистрСведений Тогда
				ОбъектМетаданныхОбласти = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				ЭтоНезависимыйРегистрСведений = (ОбъектМетаданныхОбласти.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый);
			Иначе
				ЭтоНезависимыйРегистрСведений = Ложь;
			КонецЕсли;
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			
			Если ЭтоНезависимыйРегистрСведений Тогда
				
				НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
				НаборЗаписей.Записать();
				
			Иначе
				
				ПараметрыВыборки = ПараметрыВыборки(ПолноеИмяОбъектаМетаданных);
				ИмяПоляРегистратор = ПараметрыВыборки.ИмяПоляРегистратор;
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ РАЗЛИЧНЫЕ
				|	_XMLВыгрузка_Таблица.Регистратор КАК Регистратор
				|ИЗ
				|	" + ПараметрыВыборки.Таблица + " КАК _XMLВыгрузка_Таблица";
				
				Если ИмяПоляРегистратор <> "Регистратор" Тогда
					Запрос.Текст = СтрЗаменить(Запрос.Текст, "Регистратор", ИмяПоляРегистратор);
				КонецЕсли;
				
				РезультатЗапроса = Запрос.Выполнить();
				Выборка = РезультатЗапроса.Выбрать();
				Пока Выборка.Следующий() Цикл
					НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
					НаборЗаписей.Отбор[ИмяПоляРегистратор].Установить(Выборка[ИмяПоляРегистратор]);
					НаборЗаписей.ОбменДанными.Загрузка = Истина;
					НаборЗаписей.Записать();
				КонецЦикла;
				
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Пользователи
	Если УдалитьПользователей Тогда
		
		ПервыйАдминистратор = Неопределено;
		
		Для Каждого ПользовательИБ Из ПользователиИнформационнойБазы.ПолучитьПользователей() Цикл
			
			Если ПервыйАдминистратор = Неопределено И Пользователи.ЭтоПолноправныйПользователь(ПользовательИБ, Истина, Ложь) Тогда
				
				// Отложим удаление администратора, чтобы на момент его удаления все остальные
				// пользователи информационной базы уже были удалены
				ПервыйАдминистратор = ПользовательИБ;
				
			Иначе
				
				ПользовательИБ.Удалить();
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПервыйАдминистратор <> Неопределено Тогда
			ПервыйАдминистратор.Удалить();
		КонецЕсли;
		
	КонецЕсли;
	
	// Настройки
	Хранилища = Новый Массив;
	Хранилища.Добавить(ХранилищеВариантовОтчетов);
	Хранилища.Добавить(ХранилищеНастроекДанныхФорм);
	Хранилища.Добавить(ХранилищеОбщихНастроек);
	Хранилища.Добавить(ХранилищеПользовательскихНастроекОтчетов);
	Хранилища.Добавить(ХранилищеСистемныхНастроек);
	
	Для Каждого Хранилище Из Хранилища Цикл
		Если ТипЗнч(Хранилище) <> Тип("СтандартноеХранилищеНастроекМенеджер") Тогда
			// Настройки будут удалены при очистке данных
			Продолжить;
		КонецЕсли;
		
		Хранилище.Удалить(Неопределено, Неопределено, Неопределено);
	КонецЦикла;
	
КонецПроцедуры

// Процедура одноименного регламентного задания.
// Находит все области данных со статусами, требующими обработки
// прикладным приложением и при необходимости планирует запуск ФЗ
// по их обслуживанию.
// 
Процедура ОбслуживаниеОбластейДанных() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	МаксимальноеКоличествоПовторов = 3;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
	|	ОбластиДанных.Статус КАК Статус,
	|	ОбластиДанных.ИдентификаторВыгрузки КАК ИдентификаторВыгрузки,
	|	ОбластиДанных.Вариант КАК Вариант
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Новая), ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.КУдалению))
	|	И ОбластиДанных.ОшибкаОбработки = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Выполняется = 0;
	
	Пока Выборка.Следующий() Цикл
		
		Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
			РегистрыСведений.ОбластиДанных,
			Новый Структура(РазделительВспомогательныхДанных(), Выборка.ОбластьДанных));
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			Продолжить;
		КонецПопытки;
		
		Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанныхВспомогательныеДанные = Выборка.ОбластьДанных;
		Менеджер.Прочитать();
		
		Если Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию";
		ИначеЕсли Менеджер.Статус = Перечисления.СтатусыОбластейДанных.КУдалению Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ОчиститьОбластьДанных";
		Иначе
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		Если Менеджер.Повтор < МаксимальноеКоличествоПовторов Тогда
		
			ОтборЗадания = Новый Структура;
			ОтборЗадания.Вставить("ИмяМетода", ИмяМетода);
			ОтборЗадания.Вставить("Ключ"     , "1");
			ОтборЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
			Если Задания.Количество() > 0 Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Продолжить;
			КонецЕсли;
			
			Менеджер.Повтор = Менеджер.Повтор + 1;
			
			КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(КопияМенеджера, Менеджер);
			Менеджер = КопияМенеджера;
			
			Менеджер.Записать();

			ПараметрыМетода = Новый Массив;
			ПараметрыМетода.Добавить(Выборка.ОбластьДанных);
			
			Если Выборка.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда
				
				ПараметрыМетода.Добавить(Выборка.ИдентификаторВыгрузки);
				Если ЗначениеЗаполнено(Выборка.Вариант) Тогда
					ПараметрыМетода.Добавить(Выборка.Вариант);
				КонецЕсли;
			КонецЕсли;
			
			ПараметрыЗадания = Новый Структура;
			ПараметрыЗадания.Вставить("ИмяМетода"    , ИмяМетода);
			ПараметрыЗадания.Вставить("Параметры"    , ПараметрыМетода);
			ПараметрыЗадания.Вставить("Ключ"         , "1");
			ПараметрыЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			ПараметрыЗадания.Вставить("ЭксклюзивноеВыполнение", Истина);
			
			ОчередьЗаданий.ДобавитьЗадание(ПараметрыЗадания);
			
			РазблокироватьДанныеДляРедактирования(Ключ);
		Иначе
			
			СменитьСтатусОбластиИУведомитьМенеджер(Менеджер, ?(Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая,
				"ФатальнаяОшибка", "ОшибкаУдаления"), НСтр("ru = 'Исчерпано количество попыток обработки области'"));
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает прокси web-сервиса для синхронизации административных действий в сервисе.
// 
// Возвращаемое значение: 
// WSПрокси.
// Прокси менеджера сервиса. 
// 
Функция ПолучитьПроксиМенеджераСервиса(Знач ПарольПользователя = Неопределено) Экспорт
	
	АдресМенеджераСервиса = Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	АдресСервиса = АдресМенеджераСервиса + "/ws/ManageApplication_1_0_3_1?wsdl";
	
	Если ПарольПользователя = Неопределено Тогда
		ИмяПользователя = Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить();
		ПарольПользователя = Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить();
	Иначе
		ИмяПользователя = ИмяПользователя();
	КонецЕсли;
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/ManageApplication/1.0.3.1",
		"ManageApplication_1_0_3_1", , ИмяПользователя, ПарольПользователя, 20);
		
	Возврат Прокси;
	
КонецФункции

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование = Неопределено, Знач ОбластьДанных = Неопределено) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
		ВызватьИсключение(НСтр("ru = 'Изменить разделение сеанса возможно только из сеанса запущенного без указания разделителей'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Использование <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхИспользование = Использование;
	КонецЕсли;
	
	Если ОбластьДанных <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхЗначение = ОбластьДанных;
	КонецЕсли;
	
	ПриИзмененииОбластиДанных();
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		Если НЕ ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			ВызватьИсключение(НСтр("ru = 'Не установлено значение разделителя'"));
		КонецЕсли;
		
		// Получим значение разделителя текущей области данных
		Возврат ПараметрыСеанса.ОбластьДанныхЗначение;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	Возврат ПараметрыСеанса.ОбластьДанныхИспользование;
	
КонецФункции

// Добавляет дополнительные параметры в структуру параметров работы клиента
// при работе в модели сервиса.
//
// Параметры:
//  Параметры - Структура - структура параметров работы клиента
//
Процедура ДобавитьПараметрыРаботыКлиентаВМоделиСервиса(Знач Параметры) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено()
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПредставлениеОбластиДанных.Значение КАК Представление
	|ИЗ
	|	Константа.ПредставлениеОбластиДанных КАК ПредставлениеОбластиДанных
	|ГДЕ
	|	ПредставлениеОбластиДанных.ОбластьДанныхВспомогательныеДанные = &ОбластьДанныхВспомогательныеДанные";
	УстановитьПривилегированныйРежим(Истина);
	Запрос.УстановитьПараметр("ОбластьДанныхВспомогательныеДанные", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	// Считаем данные условно неизменяемыми
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	Если НЕ Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", 
				Формат(ОбщегоНазначения.ЗначениеРазделителяСеанса(), "ЧН=0; ЧГ=") +  " - " + Выборка.Представление);
		ИначеЕсли НЕ ПустаяСтрока(Выборка.Представление) Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", Выборка.Представление);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет описание параметра по имени константы в таблицу параметров.
// Возвращает добавленный параметр.
//
// Параметры: 
// ТаблицаПараметров - Таблица значений - таблица описания параметров ИБ
// ИмяКонстанты - Строка - имя константы, которую необходимо добавить в
// параметры ИБ
//
// Возвращаемое значение: 
// Строка таблицы значений.
// Строка содержащая описание добавленного параметра. 
// 
Функция ДобавитьКонстантуВТаблицуПараметровИБ(Знач ТаблицаПараметров, Знач ИмяКонстанты) Экспорт
	
	МетаданныеКонстанты = Метаданные.Константы[ИмяКонстанты];
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = МетаданныеКонстанты.Имя;
	СтрокаПараметра.Описание = МетаданныеКонстанты.Представление();
	СтрокаПараметра.Тип = МетаданныеКонстанты.Тип;
	
	Возврат СтрокаПараметра;
	
КонецФункции

// Возвращает таблицу описания параметров ИБ
//
// Возвращаемое значение: 
// Таблица значений.
// Таблица описывающая параметры ИБ.
// Колонки:
// Имя - Строка - имя параметра.
// Описание - Строка - описание параметра для отображения в пользовательском интерфейсе
// ЗапретЧтения - Булево - признак невозможности считывания параметра ИБ. Может установлен
//                         например для паролей.
// ЗапретЗаписи - Булево - признак невозможности изменения параметра ИБ.
// Тип - Описание типов - тип значения параметра. Допускается использовать только примитивные
//                         типы и перечисления присутствующие в управляющем приложении.
// 
Функция ПолучитьТаблицуПараметровИБ() Экспорт
	
	ТаблицаПараметров = ПолучитьПустуюТаблицуПараметровИБ();
	
	ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	
	РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ(ТаблицаПараметров);
	
	Возврат ТаблицаПараметров;
	
КонецФункции

// Получает имя приложения, так как его задал Абонент.
//
// Возвращаемое значение - Строка - имя приложения.
//
Функция ПолучитьИмяПриложения() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ПредставлениеОбластиДанных.Получить();
	
КонецФункции

// Возвращает размер блоков в Мб для передачи больших файлов частями.
//
Функция ПолучитьРазмерБлокаПередачиФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РазмерБлокаПередачиФайла = Константы.РазмерБлокаПередачиФайла.Получить(); // Мб
	Если Не ЗначениеЗаполнено(РазмерБлокаПередачиФайла) Тогда
		РазмерБлокаПередачиФайла = 20;
	КонецЕсли;
	Возврат РазмерБлокаПередачиФайла;

КонецФункции

// Сериализует объект структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Строка - Сериализованное значение объекта структурного типа.
//
Функция ЗаписатьСтруктурныйОбъектXDTOВСтроку(Знач ЗначениеСтруктурногоТипа) Экспорт
	
	ОбъектXDTO = СтруктурныйОбъектВОбъектXDTO(ЗначениеСтруктурногоТипа);
	
	Возврат ЗаписатьЗначениеВСтроку(ОбъектXDTO);
	
КонецФункции

// Кодирует строковое значение по алгоритму base64
//
// Параметры:
// Строка - Строка.
//
// Возвращаемое значение:
// Строка - base64-представление.
//
Функция СтрокаВBase64(Знач Строка) Экспорт
	
	Хранилище = Новый ХранилищеЗначения(Строка, Новый СжатиеДанных(9));
	
	Возврат XMLСтрока(Хранилище);
	
КонецФункции

// Декодирует base64-представление строки в исходное значение.
//
// Параметры:
// СтрокаBase64 - Строка.
//
// Возвращаемое значение:
// Строка.
//
Функция Base64ВСтроку(Знач СтрокаBase64) Экспорт
	
	Хранилище = XMLЗначение(Тип("ХранилищеЗначения"), СтрокаBase64);
	
	Возврат Хранилище.Получить();
	
КонецФункции

// Возвращает часовой пояс области данных.
// Предназначена для вызова из сеансов с неустановленным использованием
// разделителей. В сеансах с установленным использованием разделителей
// следует использовать ПолучитьЧасовойПоясИнформационнойБазы()
//
// Параметры:
//  ОбластьДанных - Число - значение разделителя области данных, часовой
//   пояс которой требуется получить.
//
// Возвращаемое значение:
//  Строка, Неопределено - часовой пояс области данных, Неопределено
//   если часовой пояс не задан
//
Функция ПолучитьЧасовойПоясОбластиДанных(Знач ОбластьДанных) Экспорт
	
	Менеджер = Константы.ЧасовойПоясОбластиДанных.СоздатьМенеджерЗначения();
	Менеджер.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
	Менеджер.Прочитать();
	ЧасовойПояс = Менеджер.Значение;
	
	Если Не ЗначениеЗаполнено(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Возврат ЧасовойПояс;
	
КонецФункции

// Возвращает внутренний адрес менеджера сервиса
//
// Возвращаемое значение:
//  Строка - внутренний адрес менеджера сервиса
//
Функция ВнутреннийАдресМенеджераСервиса() Экспорт
	
	Возврат Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	
КонецФункции

// Возвращает имя служебного пользователя менеджера сервиса
//
// Возвращаемое значение:
//  Строка - имя служебного пользователя менеджера сервиса
//
Функция ИмяСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Возврат Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить();
	
КонецФункции

// Возвращает пароль служебного пользователя менеджера сервиса
//
// Возвращаемое значение:
//  Строка - пароль служебного пользователя менеджера сервиса
//
Функция ПарольСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Возврат Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить();
	
КонецФункции

// Обрабатывает информация об ошибке полученную из web-сервиса.
// В случае если передана не пустая информация об ошибке, записывает
// подробное представление ошибки в журнал регистрации и вызывает
// исключение с текстом краткого представления об ошибке.
//
Процедура ОбработатьИнформациюОбОшибкеWebСервиса(Знач ИнформацияОбОшибке) Экспорт
	
	Если ИнформацияОбОшибке = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Резервное копирование приложений.Ошибка вызова операции web-сервиса'", 
		ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка,
		,
		,
		ИнформацияОбОшибке.DetailErrorDescription);
		
	ВызватьИсключение ИнформацияОбОшибке.BriefErrorDescription;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Возвращает полное имя файла, полученного из файлового хранилища МС по его идентификатору.
//
// Параметры:
// ИДФайла - УникальныйИдентификатор - Идентификатор файла в файловом хранилище МС.
//
// Возвращаемое значение:
// Строка - Полное имя извлеченного файла.
//
Функция ПолучитьФайлИзХранилищаМенеджераСервиса(Знач ИДФайла) Экспорт
	
	АдресМенеджераСервиса = Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", АдресМенеджераСервиса);
	ПараметрыДоступаКХранилищу.Вставить("UserName", Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("Password", Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить());
	
	ОписаниеФайла = ПолучитьФайлИзХранилища(ИДФайла, ПараметрыДоступаКХранилищу, Истина, Истина);
	Если ОписаниеФайла = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СвойстваФайла = Новый Файл(ОписаниеФайла.ПолноеИмя);
	Если Не СвойстваФайла.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СвойстваФайла.ПолноеИмя;
	
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилищеМенеджераСервиса(Знач АдресДанныеФайл, Знач ИмяФайла = "") Экспорт
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", Константы.ВнутреннийАдресМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("UserName", Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("Password", Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить());
	
	Возврат ПоместитьФайлВХранилище(АдресДанныеФайл, ПараметрыДоступаКХранилищу, ИмяФайла);

КонецФункции

///////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Объявляет события подсистемы РаботаВМоделиСервиса:
//
// Серверные события:
//   ПриУдаленииОбластиДанных,
//   ПриПолученииТаблицыПараметровИБ,
//   ПриУстановкеЗначенийПараметровИБ,
//   ПриЗаполненииТаблицыПараметровИБ,
//   ПриУстановкеПравПоУмолчанию,
//   ПослеЗагрузкиДанныхИзДругойМодели.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Вызывается при удалении области данных.
	// В процедуре необходимо удалить данные области данных, которые не
	// могут быть удалены стандартным механизмом
	//
	// Параметры:
	// ОбластьДанных - Тип значения разделителя - значение разделителя
	// удаляемой области данных.
	//
	// Синтаксис:
	// Процедура ПриУдаленииОбластиДанных(Знач ОбластьДанных) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУдаленииОбластиДанных");
	
	// Формирует список параметров ИБ.
	//
	// Параметры:
	// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
	// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ()
	//
	// Синтаксис:
	// Процедура ПриПолученииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриПолученииТаблицыПараметровИБ");
	
	// Вызывается перед попыткой записи значений параметров ИБ в одноименные
	// константы.
	//
	// Параметры:
	// ЗначенияПараметров - Структура - значения параметров которые требуется установить.
	// В случае если значение параметра устанавливается в данной процедуре из структуры
	// необходимо удалить соответствующую пару КлючИЗначение
	//
	// Синтаксис:
	// Процедура ПриУстановкеЗначенийПараметровИБ(Знач ЗначенияПараметров) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПриУстановкеЗначенийПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУстановкеЗначенийПараметровИБ");
	
	// Формирует список параметров ИБ.
	//
	// Параметры:
	// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
	// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ()
	//
	// Синтаксис:
	// Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриЗаполненииТаблицыПараметровИБ");
	
	// Устанавливает пользователю права по умолчанию.
	// Вызывается при работе в модели сервиса, в случае обновления в менеджере
	// сервиса прав пользователя без прав администрирования.
	//
	// Параметры:
	//  Пользователь - СправочникСсылка.Пользователи - пользователь, которому
	//   требуется установить права по умолчанию
	//
	// Синтаксис:
	// Процедура ПриУстановкеПравПоУмолчанию(Пользователь) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.УстановитьПраваПоУмолчанию).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУстановкеПравПоУмолчанию");
	
	// Вызывается после окончания загрузки данных из локальной версии
	// в область данных сервиса или наоборот.
	//
	// Синтаксис:
	// Процедура ПослеЗагрузкиДанныхИзДругойМодели() Экспорт
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПослеЗагрузкиДанныхИзДругойМодели");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПоставляемыеДанные") Тогда
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ПоставляемыеДанные\ПриОпределенииОбработчиковПоставляемыхДанных"].Добавить(
				"РаботаВМоделиСервиса");
	КонецЕсли;
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий") Тогда
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииПсевдонимовОбработчиков"].Добавить(
				"РаботаВМоделиСервиса");
	
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий"].Добавить(
				"РаботаВМоделиСервиса");
	КонецЕсли;
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриВключенииРазделенияПоОбластямДанных"].Добавить(
			"РаботаВМоделиСервисаПереопределяемый");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиентскойЛогикиСтандартныхПодсистемПриЗапуске"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиентскойЛогикиСтандартныхПодсистем"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаДанных\ПриОпределенииОбъектовМетаданныхИсключаемыхИзВыгрузкиЗагрузки"].Добавить(
			"РаботаВМоделиСервиса");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему

// Определяет заголовок общей формы "ИнформационныйЦентрРабочийСтол".
//
// Параметры:
//	ЗаголовокФормы - Строка - заголовок формы.
//
Процедура ПриОпределенииЗаголовкаОсновнойФормыИнформационныйЦентр(ЗаголовокФормы) Экспорт
	
	ПолученныйЗаголовок = ПолучитьИмяПриложения();
	Если Не ПустаяСтрока(ПолученныйЗаголовок) Тогда 
		ЗаголовокФормы = ПолученныйЗаголовок;
	КонецЕсли;
	
КонецПроцедуры

// Заполняет соответствие имен методов их псевдонимам для вызова из очереди заданий
//
// Параметры:
//  СоответствиеИменПсевдонимам - Соответствие
//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных
//   Значение - Имя метода для вызова, например РаботаВМоделиСервиса.ОчиститьОбластьДанных
//    В качестве значения можно указать Неопределено, в этом случае считается что имя 
//    совпадает с псевдонимом
//
Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию");
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ОчиститьОбластьДанных");
	
КонецПроцедуры

// Формирует таблицу регламентных заданий
// с признаком использования в модели сервиса
//
// Параметры:
// ТаблицаИспользования - ТаблицаЗначений - таблица, которую необходимо 
// заполнить регламентными заданиями и признаком использования, колонки:
//  РегламентноеЗадание - Строка - имя предопределенного регламентного задания
//  Использование - Булево - Истина, если регламентное задание должно
//   выполняться в модели сервиса. Ложь - если не должно.
//
Процедура ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования) Экспорт
	
	НоваяСтрока = ТаблицаИспользования.Добавить();
	НоваяСтрока.РегламентноеЗадание = "ОбслуживаниеОбластейДанных";
	НоваяСтрока.Использование       = Истина;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Проверка безопасного режима разделения данных

// Проверка безопасного режима разделения данных.
// Только для вызова из модуля сеанса.
//
Процедура ПриПроверкеВключенияБезопасногоРежимаРазделенияДанных() Экспорт
	
	Если НЕ БезопасныйРежим()
		И ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных()
		И НЕ ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
		
		РазделениеПереключено = Неопределено;
		Попытка
			ПараметрыСеанса.ОбластьДанныхИспользование = Ложь; // Особый случай, стандартную функцию использовать нельзя
			РазделениеПереключено = Истина;
		Исключение
			// На правильно опубликованной ИБ ожидается ошибка нарушения прав доступа
			РазделениеПереключено = Ложь;
		КонецПопытки;
		
		Если РазделениеПереключено Тогда
			// Не установлен режим безопасного разделения данных
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Ошибка публикации'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				НСтр("ru = 'При публикации не включен режим безопасного разделения данных'"));
			ВызватьИсключение(НСтр("ru = 'Информационная база опубликована некорректно. Работа сеанса будет прекращена.'"));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Проверка блокировки области данных при запуске

// Проверка заблокированности области данных при запуске.
// Только для вызова из СтандартныеПодсистемыСервер.ДобавитьПараметрыРаботыКлиентаПриЗапуске().
//
Процедура ПриПроверкеБлокировкиОбластиДанныхПриЗапуске() Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
			И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных()
			И ОбластьДанныхЗаблокирована(ОбщегоНазначения.ЗначениеРазделителяСеанса()) Тогда
		
		ВызватьИсключение НСтр("ru = 'Запуск приложения временно недоступен (выполняются регламентные операции по обслуживанию приложения).
                                |Попробуйте запустить приложение через несколько минут.'");
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных

// Обработчик подписки на событие КонтрольНеразделенныхОбъектовПриЗаписи
//
Процедура КонтрольНеразделенныхОбъектовПриЗаписи(Источник, Отказ) Экспорт
	
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

// Обработчик подписки на событие КонтрольНеразделенныхНаборовЗаписейПриЗаписи
//
Процедура КонтрольНеразделенныхНаборовЗаписейПриЗаписи(Источник, Отказ, Замещение) Экспорт
	
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбработатьВспомогательныеДанные(
		ОбъектВспомогательныхДанных,
		Истина,
		Ложь);
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбработатьВспомогательныеДанные(
		ОбъектВспомогательныхДанных,
		Ложь,
		Истина);
	
КонецПроцедуры

// Создает ключ записи для регистра сведений, включенного в состав разделителя ОбластьДанныхВспомогательныеДанные.
//
// Параметры:
//  Менеджер - РегистрСведенийМенеджер, менеджер регистра сведений, для которого требуется
//    получить ключ записи,
//  ЗначенияКлюча - Структура, содержащая значения для заполнения свойств ключа записи.
//    Имена элементов структуры должны соответствовать именам ключевых полей,
//
// Возвращаемое значение: РегистрСведенийКлючЗаписи.
//
Функция СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(Знач Менеджер, Знач ЗначенияКлюча) Экспорт
	
	Ключ = Менеджер.СоздатьКлючЗаписи(ЗначенияКлюча);
	
	ОбластьДанных = Неопределено;
	Разделитель = РазделительВспомогательныхДанных();
	
	Если ЗначенияКлюча.Свойство(Разделитель, ОбластьДанных) Тогда
		
		Если Ключ[Разделитель] <> ОбластьДанных Тогда
			
			Объект = СериализаторXDTO.ЗаписатьXDTO(Ключ);
			Объект[Разделитель] = ОбластьДанных;
			Ключ = СериализаторXDTO.ПрочитатьXDTO(Объект);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ключ;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяДокумента(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Документ", "Document");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяСправочника(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Справочник", "Catalog");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПеречисления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перечисление", "Enum");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПланаОбмена(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланОбмена", "ExchangePlan");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик" по
//  полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПланаВидовХарактеристик(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовХарактеристик", "ChartOfCharacteristicTypes");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяБизнесПроцесса(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "БизнесПроцесс", "BusinessProcess");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача" по полному имени объекта
//  метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяЗадачи(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Задача", "Task");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов" по полному имени объекта
//  метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПланаСчетов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланСчетов", "ChartOfAccounts");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПланаВидовРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовРасчета", "ChartOfCalculationTypes");
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегистраСведений(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрСведений", "InformationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегистраНакопления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрНакопления", "AccumulationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегистраБухгалтерии(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрБухгалтерии", "AccountingRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегистраРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрРасчета", "CalculationRegister")
		И Не ЭтоПолноеИмяПерерасчета(ПолноеИмя);
	
КонецФункции

// Перерасчеты

// Определяет принадлежность объекта метаданных к типу "Перерасчет" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПерерасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перерасчет", "Recalculation", 2);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяКонстанты(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Константа", "Constant");
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяЖурналаДокументов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ЖурналДокументов", "DocumentJournal");
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяПоследовательности(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Последовательность", "Sequence");
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания" по полному имени
//  объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегламентногоЗадания(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегламентноеЗадание", "ScheduledJob");
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяРегистра(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяРегистраСведений(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраНакопления(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраБухгалтерии(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраРасчета(ПолноеИмя)
	;
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя – Строка, полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу
//
// Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПолноеИмяОбъектаСсылочногоТипа(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяСправочника(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяДокумента(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяБизнесПроцесса(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяЗадачи(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаСчетов(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаОбмена(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмя)
	;
	
КонецФункции

// Для внутреннего использования.
//
Функция ПараметрыВыборки(Знач ПолноеИмяОбъектаМетаданных) Экспорт
	
	Результат = Новый Структура("Таблица,ИмяПоляРегистратор");
	
	Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
			ИЛИ ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
		
		Результат.Таблица = ПолноеИмяОбъектаМетаданных;
		Результат.ИмяПоляРегистратор = "Регистратор";
		
	ИначеЕсли ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) Тогда
		
		Подстроки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмяОбъектаМетаданных, ".");
		Результат.Таблица = Подстроки[0] + "." + Подстроки[1] + "." + Подстроки[3];
		Результат.ИмяПоляРегистратор = "ОбъектПерерасчета";
		
	Иначе
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Функция ПараметрыВыборки() не должна использоваться для объекта %1.'"),
			ПолноеИмяОбъектаМетаданных);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Возвращает полный путь к каталогу временных файлов.
//
// Возвращаемое значение:
// Строка - Полный путь к каталогу временных файлов.
//
Функция ПолучитьОбщийКаталогВременныхФайлов()
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Linux_x86
		ИЛИ ТипПлатформыСервера = ТипПлатформы.Linux_x86_64 Тогда
		
		ОбщийВременныйКаталог = Константы.ОбщийКаталогВременныхФайловLinux.Получить();
		РазделительПути = "/";
	Иначе
		ОбщийВременныйКаталог = Константы.ОбщийКаталогВременныхФайлов.Получить();
		РазделительПути = "\";
	КонецЕсли;
	
	Если ПустаяСтрока(ОбщийВременныйКаталог) Тогда
		ОбщийВременныйКаталог = СокрЛП(КаталогВременныхФайлов());
	Иначе
		ОбщийВременныйКаталог = СокрЛП(ОбщийВременныйКаталог);
	КонецЕсли;
	
	Если Прав(ОбщийВременныйКаталог, 1) <> РазделительПути Тогда
		ОбщийВременныйКаталог = ОбщийВременныйКаталог + РазделительПути;
	КонецЕсли;
	
	Возврат ОбщийВременныйКаталог;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Подготовка областей данных

// Получает в транзакции менеджер записи для регистра ОбластиДанных
//
// Параметры:
//  ОбластьДанных - номер области данных
//  Статус - Перечисления.СтатусыОбластейДанных, ожидаемый статус области
//
// Возвращаемое значение:
//  РегистрыСведений.ОбластиДанных.МенеджерЗаписи
//
Функция ПолучитьМенеджерЗаписиОбластиДанных(Знач ОбластьДанных, Знач Статус)
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("РегистрСведений.ОбластиДанных");
		Элемент.УстановитьЗначение("ОбластьДанныхВспомогательныеДанные", ОбластьДанных);
		Элемент.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
		МенеджерЗаписи.Прочитать();
		
		Если НЕ МенеджерЗаписи.Выбран() Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не найдена'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		ИначеЕсли МенеджерЗаписи.Статус <> Статус Тогда
			ШаблонСообщения = НСтр("ru = 'Статус области данных %1 не равен ""%2""'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных, Статус);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подготовка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат МенеджерЗаписи;
	
КонецФункции
	
// Обновляет статус области в регистре ОбластиДанных, отправляет сообщение в менеджер сервиса
//
// Параметры:
//  МенеджерЗаписи - РегистрыСведений.ОбластиДанных.МенеджерЗаписи
//  РезультатПодготовки - строка, одна из "Успех", "ТребуетсяКонвертация", "ФатальнаяОшибка",
//    "ОшибкаУдаления", "ОбластьУдалена" 
//  СообщениеОбОшибке - строка
//
Процедура СменитьСтатусОбластиИУведомитьМенеджер(Знач МенеджерЗаписи, Знач РезультатПодготовки, Знач СообщениеОбОшибке)
	
	КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(КопияМенеджера, МенеджерЗаписи);
	МенеджерЗаписи = КопияМенеджера;

	ВключатьСообщениеОбОшибке = Ложь;
	Если РезультатПодготовки = "Успех" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Используется;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОбластьДанныхПодготовлена();
	ИначеЕсли РезультатПодготовки = "ТребуетсяКонвертация" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.ИмпортИзФайла;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаПодготовкиОбластиДанныхТребуетсяКонвертация();
	ИначеЕсли РезультатПодготовки = "ОбластьУдалена" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОбластьДанныхУдалена();
	ИначеЕсли РезультатПодготовки = "ФатальнаяОшибка" Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подготовка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаПодготовкиОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	ИначеЕсли РезультатПодготовки = "ОшибкаУдаления" Тогда
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаУдаленияОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	Иначе
		ВызватьИсключение НСтр("ru = 'Неожиданный код возврата'");
	КонецЕсли;
	
	// Отправить сообщение о готовности области в менеджер сервиса
	Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(ТипСообщения);
	Сообщение.Body.Zone = МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные;
	Если ВключатьСообщениеОбОшибке Тогда
		Сообщение.Body.ErrorDescription = СообщениеОбОшибке;
	КонецЕсли;

	НачатьТранзакцию();
	Попытка
		СообщенияВМоделиСервиса.ОтправитьСообщение(
			Сообщение,
			РаботаВМоделиСервисаПовтИсп.КонечнаяТочкаМенеджераСервиса());
		
		МенеджерЗаписи.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Загружает данные в "типовую" область
// 
// Параметры: 
//   ОбластьДанных - номер заполняемой области
//   ИДФайлаВыгрузки - ид файла начальных данных
//   Вариант - вариант начальных данных
//   СообщениеОбОшибке - строка, возвращаемая, описание ошибки
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка"
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 		  Знач Вариант, СообщениеОбОшибке)
	
	Если Константы.КопироватьОбластиДанныхИзЭталонной.Получить() Тогда
		
		Результат = ЗагрузитьОбластьИзПоставляемыхДанных(ОбластьДанных, ИДФайлаВыгрузки, Вариант, СообщениеОбОшибке);
		Если Результат <> "Успех" Тогда
			Возврат Результат;
		КонецЕсли;
		
	Иначе
		
		Результат = "Успех";
		
	КонецЕсли;
	
	ОбновлениеИнформационнойБазы.ВыполнитьОбновлениеИнформационнойБазы();
	
	Возврат Результат;
	
КонецФункции
	
// Загружает данные в область из пользовательской выгрузки
// 
// Параметры: 
//   ОбластьДанных - номер заполняемой области
//   ИДФайлаВыгрузки - ид файла начальных данных
//   СообщениеОбОшибке - строка, возвращаемая, описание ошибки
//
// Возвращаемое значение:
//  Строка - один из вариантов "ТребуетсяКонвертация", "Успех", "ФатальнаяОшибка"
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, СообщениеОбОшибке)
	
	ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
	
	Если ИмяФайлаВыгрузки = Неопределено Тогда
		
		СообщениеОбОшибке = НСтр("ru = 'Нет файла начальных данных для области'");
		
		Возврат "ФатальнаяОшибка";
	КонецЕсли;
	
	Результат = "Успех";
	Если Не ВыгрузкаЗагрузкаДанных.ПодготовитьТекущуюОбластьИзАрхива(ИмяФайлаВыгрузки) Тогда
		
		Результат = "ТребуетсяКонвертация";
		
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подготовка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Предупреждение, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных

Функция ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(Знач ПолноеИмя, Знач РусскаяЛокализация, Знач АнглийскаяЛокализация, Знач ПозицияПодстроки = 0)
	
	Подстроки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	Если Подстроки.Количество() > ПозицияПодстроки Тогда
		ИмяТипа = Подстроки.Получить(ПозицияПодстроки);
		Возврат ИмяТипа = РусскаяЛокализация ИЛИ ИмяТипа = АнглийскаяЛокализация;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП

// Зарегистрировать обработчики поставляемых данных
//
// При получении уведомления о доступности новых общих данных, вызывается процедуры
// ДоступныНовыеДанные модулей, зарегистрированных через ПолучитьОбработчикиПоставляемыхДанных.
// В процедуру передается Дескриптор - ОбъектXDTO Descriptor.
// 
// В случае, если ДоступныНовыеДанные устанавливает аргумент Загружать в значение Истина, 
// данные загружаются, дескриптор и путь к файлу с данными передаются в процедуру 
// ОбработатьНовыеДанные. Файл будет автоматически удален после завершения процедуры.
// Если в менеджере сервиса не был указан файл - значение аргумента равно Неопределено.
//
// Параметры: 
//   Обработчики, ТаблицаЗначений - таблица для добавления обработчиков. 
//       Колонки:
//        ВидДанных, строка - код вида данных, обрабатываемый обработчиком
//        КодОбработчика, строка(20) - будет использоваться при восстановлении обработки данных после сбоя
//        Обработчик,  ОбщийМодуль - модуль, содержащий следующие процедуры:
//          ДоступныНовыеДанные(Дескриптор, Загружать) Экспорт  
//          ОбработатьНовыеДанные(Дескриптор, ПутьКФайлу) Экспорт
//          ОбработкаДанныхОтменена(Дескриптор) Экспорт
//
Процедура ПриОпределенииОбработчиковПоставляемыхДанных(Обработчики) Экспорт
	
	ЗарегистрироватьОбработчикиПоставляемыхДанных(Обработчики);
	
КонецПроцедуры

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.31";
	Обработчик.Процедура = "РаботаВМоделиСервиса.ПеренестиОбластиДанных";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.9";
	Обработчик.Процедура = "РаботаВМоделиСервиса.ОтключитьРазделениеПользователейПоРазделителюВнутреннихДанных";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.МонопольныйРежим = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РаботаВМоделиСервиса.КонтрольНеразделенныхДанныхПриОбновлении";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Ложь;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РаботаВМоделиСервиса.КонтрольРазделителейПриОбновлении";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Ложь;
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации. 
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиентскойЛогикиСтандартныхПодсистемПриЗапуске(Параметры) Экспорт
	
	ДобавитьПараметрыРаботыКлиентаВМоделиСервиса(Параметры);
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиентскойЛогикиСтандартныхПодсистем(Параметры) Экспорт
	
	ДобавитьПараметрыРаботыКлиентаВМоделиСервиса(Параметры);
	
КонецПроцедуры

// Обработчик, вызываемый при определении объектов метаданных, не переносящихся между моделями при выгрузке / загрузке данных.
//
// Параметры
//  Объекты - Массив(ОбъектМетаданных).
//
Процедура ПриОпределенииОбъектовМетаданныхИсключаемыхИзВыгрузкиЗагрузки(Объекты) Экспорт
	
	Объекты.Добавить(Метаданные.Константы.КлючОбластиДанных);
	Объекты.Добавить(Метаданные.РегистрыСведений.ОбластиДанных);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вызовы в другие подсистемы

// Формирует список параметров ИБ.
//
// Параметры:
// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ()
//
Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() Тогда
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ИспользоватьРазделениеПоОбластямДанных");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "РежимИспользованияИнформационнойБазы");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "КопироватьОбластиДанныхИзЭталонной");
	КонецЕсли;
	
	ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнутреннийАдресМенеджераСервиса");
	
	ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ИмяСлужебногоПользователяМенеджераСервиса");
	
	СтрокаПараметра = ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ПарольСлужебногоПользователяМенеджераСервиса");
	СтрокаПараметра.ЗапретЧтения = Истина;
	
	// Для совместимости с предыдущими версиями
	СтрокаПараметра = ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнутреннийАдресМенеджераСервиса");
	СтрокаПараметра.Имя = "URLСервиса";
	
	СтрокаПараметра = ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ИмяСлужебногоПользователяМенеджераСервиса");
	СтрокаПараметра.Имя = "ИмяСлужебногоПользователяСервиса";
	
	СтрокаПараметра = ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ПарольСлужебногоПользователяМенеджераСервиса");
	СтрокаПараметра.Имя = "ПарольСлужебногоПользователяСервиса";
	СтрокаПараметра.ЗапретЧтения = Истина;
	// Конец Для совместимости с предыдущими версиями
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ВерсияКонфигурации";
	СтрокаПараметра.Описание = НСтр("ru = 'Версия конфигурации'");
	СтрокаПараметра.ЗапретЗаписи = Истина;
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная));
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриЗаполненииТаблицыПараметровИБ");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа через Агента сервиса

// Для текущей ИБ удаляет заданные сеансы и разрывает соединения через Агент сервиса.
// Сеансы задаются своими номерами во входном массиве либо одним номером.
//
// Параметры:
//   СеансыКУдалению - Массив; Число - Числовой массив номеров сеансов или один номер сеанса.
//   ПараметрыАдминистрированияИБ - Структура с полями
// 	   ИмяАдминистратораИБ - Строка.
//	   ПарольАдминистратораИБ - Строка.
//	   ИмяАдминистратораКластера - Строка.
//	   ПарольАдминистратораКластера - Строка.
//	   ПортКластераСерверов - Число.
//	   ПортАгентаСервера - Число.
//
// Возвращаемое значение:
//   Булево - Истина, если успешно.
//
Функция УдалитьСеансыИРазорватьСоединенияЧерезАгентСервиса(Знач СеансыКУдалению, Знач ПараметрыАдминистрированияИБ) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(СеансыКУдалению) = Тип("Массив") Тогда
		СписокСеансов = СеансыКУдалению;
	ИначеЕсли ТипЗнч(СеансыКУдалению) = Тип("Число") Тогда
		СписокСеансов = Новый Массив;
		СписокСеансов.Добавить(СеансыКУдалению);
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип параметра ""СеансыКУдалению"".'"));
	КонецЕсли;
	
	Если СписокСеансов.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ПубликацияАгента = Константы.АдресАгентаСервиса.Получить();
	ПользовательАгента = Константы.ИмяПользователяАгентаСервиса.Получить();
	ПарольАгента = Константы.ПарольПользователяАгентаСервиса.Получить();
	
	// Проверить с помощью версионирования, поддерживается ли нужный интерфейс.
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПубликацияАгента,
		ПользовательАгента, ПарольАгента, "УправлениеАгентом");
		
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ВызватьИсключение(НСтр("ru = 'Агент сервиса. Выборочное удаление сеансов не поддерживается в этой версии.'"));
	КонецЕсли;
	
	// Сформировать XDTO-строку входных параметров для обращения к операциям сервиса.
	
	ЗначенияПараметров = Новый Структура;
	
	// Получить для текущей ИБ параметры соединения.
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	ЗначенияПараметров.Вставить("ИнформационнаяБаза", ПараметрыСоединения.Ref);
	
	ТипПараметрыАдминистрирования = ФабрикаXDTO.Тип("http://v8.1c.ru/agent/scripts/1.0", "ClusterAdministrationInfo");
	ПараметрыАдминистрированияКластера = ФабрикаXDTO.Создать(ТипПараметрыАдминистрирования);
	ПараметрыАдминистрированияКластера.AgentConnectionString = 
		"tcp://" + ПараметрыСоединения.Srvr + ":" 
		+ Формат(ПараметрыАдминистрированияИБ.ПортАгентаСервера, "ЧГ=");
	ПараметрыАдминистрированияКластера.ClusterPort = ПараметрыАдминистрированияИБ.ПортКластераСерверов;
	ПараметрыАдминистрированияКластера.ClusterUserName = ПараметрыАдминистрированияИБ.ИмяАдминистратораКластера;
	ПараметрыАдминистрированияКластера.ClusterPassword = СтрокаВBase64(ПараметрыАдминистрированияИБ.ПарольАдминистратораКластера);
	ПараметрыАдминистрированияКластера.IBUserName = ПараметрыАдминистрированияИБ.ИмяАдминистратораИБ;
	ПараметрыАдминистрированияКластера.IBPassword = СтрокаВBase64(ПараметрыАдминистрированияИБ.ПарольАдминистратораИБ);
	
	ЗначенияПараметров.Вставить("ПараметрыАдминистрированияКластера", ПараметрыАдминистрированияКластера);
	ЗначенияПараметров.Вставить("СписокСеансов", СписокСеансов);
	
	ПараметрыXDTO = ЗаписатьСтруктурныйОбъектXDTOВСтроку(ЗначенияПараметров);
	
	// Требуется поддержка 2-й версии, в которой реализовано выборочное удаление сеансов.
	
	Прокси = ОбщегоНазначения.WSПрокси(ПубликацияАгента + "/ws/ManageAgent_1_0_2_1?wsdl",
		"http://www.1c.ru/SaaS/1.0/WS",
		"ManageAgent_1_0_2_1",
		,
		ПользовательАгента,
		ПарольАгента,
		20);
		
	
	// Выполнить действие с помощью операции Web-сервиса.
	СостояниеЗавершения = Неопределено;
	Прокси.DoAction("УдалитьСеансыПоСписку", ПараметрыXDTO, СостояниеЗавершения);
	
	Возврат СостояниеЗавершения = "ДействиеВыполнено";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с параметрами ИБ

// Возвращает пустую таблицу параметров ИБ
//
Функция ПолучитьПустуюТаблицуПараметровИБ()
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("ЗапретЧтения", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗапретЗаписи", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Тип", Новый ОписаниеТипов("ОписаниеТипов"));
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Получает описание файла по его идентификатору в регистре Файлы.
// Если хранение на диске и ПутьВместоДанных = Истина, 
// в выходной структуре Данные = Неопределено, ПолноеИмя = Полное имя файла,
// иначе Данные - двоичные данные файла, ПолноеИмя - Неопределено.
// Значение ключа Имя всегда содержит имя в хранилище.
//
// Параметры:
// ИдентификаторФайла - УникальныйИдентификатор.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ПутьВместоДанных - Булево - Что возвращать. 
// ПроверятьСуществование - Булево - Проверять ли существования файла в случае ошибки его получения.
//		
// Возвращаемое значение:
// ОписаниеФайла - Структура:
//	Имя - Строка - имя файла в хранилище.
//	Данные - ДвоичныеДанные - данные файла.
//	ПолноеИмя - Строка - полное имя файла.
//			  - Файл будет удален автоматически по истечении срока хранения временных файлов.
//
Функция ПолучитьФайлИзХранилища(Знач ИдентификаторФайла, Знач ПараметрыПодключения, 
	Знач ПутьВместоДанных = Ложь, Знач ПроверятьСуществование = Ложь) Экспорт
	
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСССервера(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	
	Если ОбменЧерезФС Тогда
			
		Попытка
			Попытка
				ИмяФайла = ОписаниеПрокси.Прокси.WriteFileToFS(ИдентификаторФайла);
			Исключение
				ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
					Возврат Неопределено;
				КонецЕсли;
				ВызватьИсключение ОписаниеОшибки;
			КонецПопытки;
			
			СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = СвойстваФайла.Имя;
				
				РазмерПолученногоФайла = СвойстваФайла.Размер();
				
				Если ПутьВместоДанных Тогда
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = СвойстваФайла.ПолноеИмя;
				Иначе
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(СвойстваФайла.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					Попытка
						УдалитьФайлы(СвойстваФайла.ПолноеИмя);
					Исключение
					КонецПопытки;
				КонецЕсли;
				
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Извлечение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					ИдентификаторФайла,
					РазмерПолученногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				
				Возврат ОписаниеФайла;
			Иначе
				ОбменЧерезФС = Ложь;
			КонецЕсли;
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение файла из хранилища'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
			
	КонецЕсли; // ОбменЧерезФС
	
	КоличествоЧастей = Неопределено;
	ИмяФайлаВСправочнике = Неопределено;
	РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла();
	Попытка
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			ИдентификаторПередачи = ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, КоличествоЧастей);
		Иначе
			ИдентификаторПередачи = Неопределено;
			ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, ИдентификаторПередачи, КоличествоЧастей);
		КонецЕсли;
	Исключение
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ВызватьИсключение ОписаниеОшибки;
	КонецПопытки;
	
	ИменаФайлов = Новый Массив;
	
	КаталогСборки = СоздатьКаталогСборки();
	
	Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, КоличествоЧастей);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	Иначе // 1-я версия.
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = Неопределено;
			ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеЧасти);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	КонецЕсли;
	ДанныеЧасти = Неопределено;
	
	ОписаниеПрокси.Прокси.ReleaseFile(ИдентификаторПередачи);
	
	ИмяАрхива = ПолучитьИмяВременногоФайла("zip");
	
	ОбъединитьФайлы(ИменаФайлов, ИмяАрхива);
	
	Разархиватор = Новый ЧтениеZipФайла(ИмяАрхива);
	Если Разархиватор.Элементы.Количество() > 1 Тогда
		ВызватьИсключение(НСтр("ru = 'В полученном архиве содержится более одного файла'"));
	КонецЕсли;
	
	ИмяФайла = КаталогСборки + Разархиватор.Элементы[0].Имя;
	Разархиватор.Извлечь(Разархиватор.Элементы[0], КаталогСборки);
	Разархиватор.Закрыть();
	
	ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
	ПереместитьФайл(ИмяФайла, ФайлРезультата.ПолноеИмя);
	РазмерПолученногоФайла = ФайлРезультата.Размер();
	
	ОписаниеФайла = СоздатьОписаниеФайла();
	ОписаниеФайла.Имя = ФайлРезультата.Имя;
	
	Если ПутьВместоДанных Тогда
		ОписаниеФайла.Данные = Неопределено;
		ОписаниеФайла.ПолноеИмя = ФайлРезультата.ПолноеИмя;
	Иначе
		ОписаниеФайла.Данные = Новый ДвоичныеДанные(ФайлРезультата.ПолноеИмя);
		ОписаниеФайла.ПолноеИмя = Неопределено;
		Попытка
			УдалитьФайлы(ФайлРезультата.ПолноеИмя);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяАрхива);
		УдалитьФайлы(КаталогСборки);
	Исключение
	КонецПопытки;
	
	ЗаписатьВЖурналСобытиеФайловогоХранилища(
		НСтр("ru = 'Извлечение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		ИдентификаторФайла,
		РазмерПолученногоФайла,
		ТекущаяУниверсальнаяДата() - НачалоВыполнения,
		ОбменЧерезФС);
	
	Возврат ОписаниеФайла;
	
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилище(Знач АдресДанныеФайл, Знач ПараметрыПодключения, Знач ИмяФайла = "")
	
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	Описание = ПолучитьИмяФайлаСДанными(АдресДанныеФайл, ИмяФайла);
	СвойстваФайла = Новый Файл(Описание.Имя);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСНаСервер(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	Если ОбменЧерезФС Тогда
		
		// Сохранить данные в файл.
		ОбщийКаталог = ПолучитьОбщийКаталогВременныхФайлов();
		ЦелевойФайл = Новый Файл(ОбщийКаталог + СвойстваФайла.Имя);
		Если ЦелевойФайл.Существует() Тогда
			Если СвойстваФайла.ПолноеИмя = ЦелевойФайл.ПолноеИмя Тогда // Это один и тот же файл. Его можно, не передавая, сразу читать на сервере.
				Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
				РазмерИсходногоФайла = ЦелевойФайл.Размер();
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					Результат,
					РазмерИсходногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				Возврат Результат;
				// Нельзя удалять, поскольку он является и источником.
			КонецЕсли;
			// Источник и приемник - разные файлы. Чтобы не затереть чужой файл, делаем приемнику уникальное имя.
			НовыйИД = Новый УникальныйИдентификатор;
			ЦелевойФайл = Новый Файл(ОбщийКаталог + НовыйИД + СвойстваФайла.Расширение);
		КонецЕсли;
		
		Попытка
			Если Описание.Данные = Неопределено Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ЦелевойФайл.ПолноеИмя);
			Иначе
				Описание.Данные.Записать(ЦелевойФайл.ПолноеИмя);
			КонецЕсли;
			Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
			РазмерИсходногоФайла = ЦелевойФайл.Размер();
			ЗаписатьВЖурналСобытиеФайловогоХранилища(
				НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				Результат,
				РазмерИсходногоФайла,
				ТекущаяУниверсальнаяДата() - НачалоВыполнения,
				ОбменЧерезФС);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Добавление файла. Обмен через ФС'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
		
		УдалитьВременныеФайлы(ЦелевойФайл.ПолноеИмя);
		
	КонецЕсли; // ОбменЧерезФС
		
	Если Не ОбменЧерезФС Тогда
		
		РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла(); // Мб
		ИдентификаторПередачи = Новый УникальныйИдентификатор;
		
		// Сохранить данные в файл.
		КаталогСборки = СоздатьКаталогСборки();
		ПолноеИмяФайла = КаталогСборки + СвойстваФайла.Имя;
		
		Если Описание.Данные = Неопределено тогда
			Если СвойстваФайла.Существует() Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ПолноеИмяФайла);
			Иначе
				ВызватьИсключение(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Добавление файла в хранилище. Не найден файл %1.'"), СвойстваФайла.ПолноеИмя));
			КонецЕсли;
		Иначе
			Описание.Данные.Записать(ПолноеИмяФайла);
		КонецЕсли;
		
		ЦелевойФайл = Новый Файл(ПолноеИмяФайла);
		РазмерИсходногоФайла = ЦелевойФайл.Размер();
		
		// Архивировать файл.
		ИмяНеразделенногоФайла = ПолучитьИмяВременногоФайла("zip");
		Архиватор = Новый ЗаписьZipФайла(ИмяНеразделенногоФайла, , , , УровеньСжатияZIP.Минимальный);
		Архиватор.Добавить(ПолноеИмяФайла);
		Архиватор.Записать();
		
		// Разделить файл на части.
		ИменаФайлов = РазделитьФайл(ИмяНеразделенногоФайла, РазмерБлокаПередачиФайла * 1024 * 1024, КаталогСборки); // Мб => байты.
		
		Попытка
			УдалитьФайлы(ИмяНеразделенногоФайла);
		Исключение
		КонецПопытки;
		
		// Передать файл через сервис по частям.
		КоличествоЧастей = ИменаФайлов.Количество();
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла, КоличествоЧастей);
			КонецЦикла;
		Иначе // 1-я версия.
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла);
			КонецЦикла;
		КонецЕсли;
		
		Попытка
			УдалитьФайлы(КаталогСборки);
		Исключение
		КонецПопытки;
		
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Результат = ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей); 
		Иначе // 1-я версия.
			Результат = Неопределено;
			ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей, Результат); 
		КонецЕсли;
		
		ЗаписатьВЖурналСобытиеФайловогоХранилища(
			НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			Результат,
			РазмерИсходногоФайла,
			ТекущаяУниверсальнаяДата() - НачалоВыполнения,
			ОбменЧерезФС);
		
	КонецЕсли; // Не ОбменЧерезФС
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру с именем и данными файла по адресу во временном хранилище/информации в объекте Файл/двоичным данным.
//
// Параметры:
//	АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес хранилища данных файла/Данные файла/Файл.
//	ИмяФайла - Строка.
//		
// Возвращаемое значение:
// Структура:
//   Данные - ДвоичныеДанные - Данные файла.
//   Имя - Строка - Имя файла.
//
Функция ПолучитьИмяФайлаСДанными(Знач АдресДанныеФайл, Знач ИмяФайла = "")
	
	Если ТипЗнч(АдресДанныеФайл) = Тип("Строка") Тогда // Адрес данных файла во временном хранилище.
		Если ПустаяСтрока(АдресДанныеФайл) Тогда
			ВызватьИсключение(НСтр("ru = 'Неверный адрес хранилища.'"));
		КонецЕсли;
		ДанныеФайла = ПолучитьИзВременногоХранилища(АдресДанныеФайл);
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("Файл") Тогда // Объект типа Файл.
		Если Не АдресДанныеФайл.Существует() Тогда
			ВызватьИсключение(НСтр("ru = 'Файл не найден.'"));
		КонецЕсли;
		ДанныеФайла = Неопределено;
		ИмяФайла = АдресДанныеФайл.ПолноеИмя;
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("ДвоичныеДанные") Тогда // Данные файла.
		ДанныеФайла = АдресДанныеФайл;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип данных'"));
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяФайла) Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	Возврат Новый Структура("Данные, Имя", ДанныеФайла, ИмяФайла);
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с сервера на клиент.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСССервера(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = Прокси.WriteTestFile();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = ПрочитатьПробныйФайл(ИмяФайла);
	
	Прокси.DeleteTestFile(ИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с клиента на сервер.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСНаСервер(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = ЗаписатьПробныйФайл();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Прокси.ReadTestFile(ИмяФайла);
	
	ПолноеИмяФайла = ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла;
	УдалитьВременныеФайлы(ПолноеИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Создать каталог с уникальным именем для размещения частей разделяемого файла.
//
// Возвращаемое значение:
// Строка - Имя каталога.
//
Функция СоздатьКаталогСборки()
	
	КаталогСборки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогСборки);
	Возврат КаталогСборки + ОбщегоНазначенияКлиентСервер.РазделительПути();
	
КонецФункции

// Читает тестовый файл с диска, сравнивая содержимое и имя: они должны совпадать.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// ИмяФайла - Строка - Без пути.
//
// Возвращаемое значение:
// Булево - Истина, если файл успешно прочтен и содержимое совпадает с его именем.
//
Функция ПрочитатьПробныйФайл(Знач ИмяФайла)
	
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
	Если СвойстваФайла.Существует() Тогда
		Текст = Новый ЧтениеТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
		ТестовыйИД = Текст.Прочитать();
		Текст.Закрыть();
		Возврат ТестовыйИД = СвойстваФайла.ИмяБезРасширения;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Записывает тестовый файл на диск, возвращая его имя и размер.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// РазмерФайла - Число.
//
// Возвращаемое значение:
// Строка - Имя пробного файла без пути.
//
Функция ЗаписатьПробныйФайл() Экспорт
	
	НовыйИД = Новый УникальныйИдентификатор;
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + НовыйИД + ".tmp");
	
	Текст = Новый ЗаписьТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
	Текст.Записать(НовыйИД);
	Текст.Закрыть();
	
	Возврат СвойстваФайла.Имя;
	
КонецФункции

// Создает незаполненную структуру нужного формата.
//
// Возвращаемое значение:
// Структура:
//   Имя - Строка - Имя файла в хранилище.
//   Данные - ДвоичныеДанные - Данные файла.
// 	 ПолноеИмя - Строка - Имя файла с путем.
//
Функция СоздатьОписаниеФайла()
	
	ОписаниеФайла = Новый Структура;
	ОписаниеФайла.Вставить("Имя");
	ОписаниеФайла.Вставить("Данные");
	ОписаниеФайла.Вставить("ПолноеИмя");
	ОписаниеФайла.Вставить("ОбязательныеПараметры", "Имя"); // Обязательные к заполнению параметры.
	Возврат ОписаниеФайла;
	
КонецФункции

// Получает объект WSПрокси Web-сервиса, заданного своим базовым именем.
//
// Параметры:
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// Возвращаемое значение:
//  Структура
//   Прокси - WSПрокси
//   ЕстьПоддержка2йВерсии - Булево
//
Функция ОписаниеПроксиСервисаПередачиФайлов(Знач ПараметрыПодключения)
	
	БазовоеИмяСервиса = "FilesTransfer";
	
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ЕстьПоддержка2йВерсии = Ложь;
		ВерсияИнтерфейса = "1.0.1.1"
	Иначе
		ЕстьПоддержка2йВерсии = Истина;
		ВерсияИнтерфейса = "1.0.2.1";
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		ПарольПользователя = ПараметрыПодключения.Password;
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	Если ВерсияИнтерфейса = Неопределено Или ВерсияИнтерфейса = "1.0.1.1" Тогда // 1-я версия.
		ИмяСервиса = БазовоеИмяСервиса;
	Иначе // Версии 2 и выше.
		ИмяСервиса = БазовоеИмяСервиса + "_" + СтрЗаменить(ВерсияИнтерфейса, ".", "_");
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("/ws/%1?wsdl", ИмяСервиса);
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, 
		"http://www.1c.ru/SaaS/1.0/WS", ИмяСервиса, , ИмяПользователя, ПарольПользователя, 600);
		
	Возврат Новый Структура("Прокси, ЕстьПоддержка2йВерсии", Прокси, ЕстьПоддержка2йВерсии);
		
КонецФункции

Процедура ЗаписатьВЖурналСобытиеФайловогоХранилища(Знач Событие,
	Знач ИдФайла, Знач Размер, Знач Длительность, Знач ПередачаЧерезФайловуюСистему)
	
	ДанныеСобытия = Новый Структура;
	ДанныеСобытия.Вставить("ИдФайла", ИдФайла);
	ДанныеСобытия.Вставить("Размер", Размер);
	ДанныеСобытия.Вставить("Длительность", Длительность);
	
	Если ПередачаЧерезФайловуюСистему Тогда
		ДанныеСобытия.Вставить("Транспорт", "file");
	Иначе
		ДанныеСобытия.Вставить("Транспорт", "ws");
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Хранилище файлов'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()) + "." + Событие,
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ОбщегоНазначения.ЗначениеВСтрокуXML(ДанныеСобытия));
	
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Временные файлы

// Удалить файл(ы) на диске.
// Если в качестве имени файла задана маска с путем, разделить его на путь и маску.
//
Процедура УдалитьВременныеФайлы(Знач ИмяФайла)
	
	Попытка
		Если Прав(ИмяФайла, 1) = "*" Тогда // Маска.
			Индекс = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(
				ИмяФайла, ОбщегоНазначенияКлиентСервер.РазделительПути());
			Если Индекс > 0 Тогда
				ПутьКФайлу = Лев(ИмяФайла, Индекс - 1);
				МаскаФайла = Сред(ИмяФайла, Индекс + 1);
				Если НайтиФайлы(ПутьКФайлу, МаскаФайла, Ложь).Количество() > 0 Тогда
					УдалитьФайлы(ПутьКФайлу, МаскаФайла);
				КонецЕсли;
			КонецЕсли;
		Иначе
			СвойстваФайла = Новый Файл(ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				СвойстваФайла.УстановитьТолькоЧтение(Ложь); // Снять атрибут.
				УдалитьФайлы(СвойстваФайла.ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции удаления временного файла'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Сериализация

Функция ЗаписатьЗначениеВСтроку(Знач Значение)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	
	Если ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		ФабрикаXDTO.ЗаписатьXML(Запись, Значение, , , , НазначениеТипаXML.Явное);
	Иначе
		СериализаторXDTO.ЗаписатьXML(Запись, Значение, НазначениеТипаXML.Явное);
	КонецЕсли;
	
	Возврат Запись.Закрыть();
		
КонецФункции

// Отражает, является ли данный тип сериализуемым.
//
// Параметры:
// СтруктурныйТип - Тип.
//
// Возвращаемое значение:
// Булево.
//
Функция СериализуемыйСтруктурныйТип(СтруктурныйТип);
	
	МассивСериализуемыхТипов = РаботаВМоделиСервисаПовтИсп.СериализуемыеСтруктурныеТипы();
	
	Для Каждого СериализуемыйТип Из МассивСериализуемыхТипов Цикл 
		Если СтруктурныйТип = СериализуемыйТип Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
		
КонецФункции

// Получает XDTO-представление объекта структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Структурный объект XDTO - XDTO-представление объекта структурного типа.
//
Функция СтруктурныйОбъектВОбъектXDTO(Знач ЗначениеСтруктурногоТипа)
	
	СтруктурныйТип = ТипЗнч(ЗначениеСтруктурногоТипа);
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	XMLТипЗначения = СериализаторXDTO.XMLТипЗнч(ЗначениеСтруктурногоТипа);
	ТипСтруктура = ФабрикаXDTO.Тип(XMLТипЗначения);
	СтруктураXDTO = ФабрикаXDTO.Создать(ТипСтруктура);
	
	// Перебор допустимых структурных типов.
	
	Если СтруктурныйТип = Тип("Структура") Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		ТипСвойство = ТипСтруктура.Свойства.Получить("Property").Тип;
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			Свойство = ФабрикаXDTO.Создать(ТипСвойство);
			Свойство.name = КлючИЗначение.Ключ;
			Свойство.Value = ЗначениеТипаВЗначениеXDTO(КлючИЗначение.Значение);
			СтруктураXDTO.Property.Добавить(Свойство);
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		Для Каждого ЗначениеЭлемента Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.Value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеЭлемента));
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.pair.Добавить(СтруктурныйОбъектВОбъектXDTO(КлючИЗначение));
		КонецЦикла;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктураXDTO.key = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Ключ);
		СтруктураXDTO.value = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Значение);
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		XDTOТипКолонкаТЗ = ТипСтруктура.Свойства.Получить("column").Тип;
		
		Для Каждого Колонка Из ЗначениеСтруктурногоТипа.Колонки Цикл
			
			КолонкаXDTO = ФабрикаXDTO.Создать(XDTOТипКолонкаТЗ);
			
			КолонкаXDTO.Name = ЗначениеТипаВЗначениеXDTO(Колонка.Имя);
			КолонкаXDTO.ValueType = СериализаторXDTO.ЗаписатьXDTO(Колонка.ТипЗначения);
			КолонкаXDTO.Title = ЗначениеТипаВЗначениеXDTO(Колонка.Заголовок);
			КолонкаXDTO.Width = ЗначениеТипаВЗначениеXDTO(Колонка.Ширина);
			
			СтруктураXDTO.column.Добавить(КолонкаXDTO);
			
		КонецЦикла;
		
		XDTOТипИндексТЗ = ТипСтруктура.Свойства.Получить("index").Тип;
		
		Для Каждого Индекс Из ЗначениеСтруктурногоТипа.Индексы Цикл
			
			ИндексXDTO = ФабрикаXDTO.Создать(XDTOТипИндексТЗ);
			
			Для Каждого ПолеИндекса Из Индекс Цикл
				ИндексXDTO.column.Добавить(ЗначениеТипаВЗначениеXDTO(ПолеИндекса));
			КонецЦикла;
			
			СтруктураXDTO.index.Добавить(ИндексXDTO);
			
		КонецЦикла;
		
		XDTOТипСтрокаТЗ = ТипСтруктура.Свойства.Получить("row").Тип;
		
		Для Каждого СтрокаТЗ Из ЗначениеСтруктурногоТипа Цикл
			
			СтрокаXDTO = ФабрикаXDTO.Создать(XDTOТипСтрокаТЗ);
			
			Для Каждого ЗначениеКолонки Из СтрокаТЗ Цикл
				СтрокаXDTO.value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеКолонки));
			КонецЦикла;
			
			СтруктураXDTO.row.Добавить(СтрокаXDTO);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураXDTO;
	
КонецФункции

// Получает объект структурного типа из XDTO-объекта.
//
// Параметры:
// ОбъектXDTO - Объект XDTO.
//
// Возвращаемое значение:
// Структурный тип ( Массив, Структура, Соответствие или их фиксированные аналоги) 
//
Функция ОбъектXDTOВСтруктурныйОбъект(ОбъектXDTO)
	
	ТипДанныхXML = Новый ТипДанныхXML(ОбъектXDTO.Тип().Имя, ОбъектXDTO.Тип().UriПространстваИмен);
	Если ВозможностьЧтенияТипаДанныхXML(ТипДанныхXML) Тогда
		СтруктурныйТип = СериализаторXDTO.ИзXMLТипа(ТипДанныхXML);
	Иначе
		Возврат ОбъектXDTO;
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Строка") Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Структура")	Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктурныйОбъект = Новый Структура;
		
		Для Каждого Свойство Из ОбъектXDTO.Property Цикл
			СтруктурныйОбъект.Вставить(Свойство.name, ЗначениеXDTOВЗначениеТипа(Свойство.Value));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Структура") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированнаяСтруктура(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		СтруктурныйОбъект = Новый Массив;
		
		Для Каждого ЭлементМассива Из ОбъектXDTO.Value Цикл
			СтруктурныйОбъект.Добавить(ЗначениеXDTOВЗначениеТипа(ЭлементМассива));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Массив") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированныйМассив(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		СтруктурныйОбъект = Новый Соответствие;
		
		Для Каждого КлючИЗначениеXDTO Из ОбъектXDTO.pair Цикл
			КлючИЗначение = ОбъектXDTOВСтруктурныйОбъект(КлючИЗначениеXDTO);
			СтруктурныйОбъект.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Соответствие") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированноеСоответствие(СтруктурныйОбъект);
		КонецЕсли;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктурныйОбъект = Новый Структура("Ключ, Значение");
		СтруктурныйОбъект.Ключ = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.key);
		СтруктурныйОбъект.Значение = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.value);
		
		Возврат СтруктурныйОбъект;
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		СтруктурныйОбъект = Новый ТаблицаЗначений;
		
		Для Каждого Колонка Из ОбъектXDTO.column Цикл
			
			СтруктурныйОбъект.Колонки.Добавить(
				ЗначениеXDTOВЗначениеТипа(Колонка.Name), 
				СериализаторXDTO.ПрочитатьXDTO(Колонка.ValueType), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Title), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Width));
				
		КонецЦикла;
		Для Каждого Индекс Из ОбъектXDTO.index Цикл
			
			ИндексСтрокой = "";
			Для Каждого ПолеИндекса Из Индекс.column Цикл
				ИндексСтрокой = ИндексСтрокой + ПолеИндекса + ", ";
			КонецЦикла;
			ИндексСтрокой = СокрЛП(ИндексСтрокой);
			Если СтрДлина(ИндексСтрокой) > 0 Тогда
				ИндексСтрокой = Лев(ИндексСтрокой, СтрДлина(ИндексСтрокой) - 1);
			КонецЕсли;
			
			СтруктурныйОбъект.Индексы.Добавить(ИндексСтрокой);
		КонецЦикла;
		Для Каждого СтрокаXDTO Из ОбъектXDTO.row Цикл
			
			СтрокаТЗ = СтруктурныйОбъект.Добавить();
			
			ЧислоКолонок = СтруктурныйОбъект.Колонки.Количество();
			Для Индекс = 0 По ЧислоКолонок - 1 Цикл 
				СтрокаТЗ[СтруктурныйОбъект.Колонки[Индекс].Имя] = ЗначениеXDTOВЗначениеТипа(СтрокаXDTO.value[Индекс]);
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат СтруктурныйОбъект;
		
	КонецЕсли;
	
КонецФункции

Функция ВозможностьЧтенияТипаДанныхXML(Знач ТипДанныхXML)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьНачалоЭлемента("Dummy");
	Запись.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	Запись.ЗаписатьСоответствиеПространстваИмен("ns1", ТипДанныхXML.URIПространстваИмен);
	Запись.ЗаписатьАтрибут("xsi:type", "ns1:" + ТипДанныхXML.ИмяТипа);
	Запись.ЗаписатьКонецЭлемента();
	
	Строка = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Строка);
	Чтение.ПерейтиКСодержимому();
	
	Возврат СериализаторXDTO.ВозможностьЧтенияXML(Чтение);
	
КонецФункции

// Получает значение простейшего типа в контексте XDTO.
//
// Параметры:
// ЗначениеТипа - Значение произвольного типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеТипаВЗначениеXDTO(Знач ЗначениеТипа)
	
	Если ЗначениеТипа = Неопределено
		Или ТипЗнч(ЗначениеТипа) = Тип("ОбъектXDTO")
		Или ТипЗнч(ЗначениеТипа) = Тип("ЗначениеXDTO") Тогда
		
		Возврат ЗначениеТипа;
		
	Иначе
		
		Если ТипЗнч(ЗначениеТипа) = Тип("Строка") Тогда
			ТипXDTO = ФабрикаXDTO.Тип("http://www.w3.org/2001/XMLSchema", "string")
		Иначе
			ТипXML = СериализаторXDTO.XMLТипЗнч(ЗначениеТипа);
			ТипXDTO = ФабрикаXDTO.Тип(ТипXML);
		КонецЕсли;
		
		Если ТипЗнч(ТипXDTO) = Тип("ТипОбъектаXDTO") Тогда // Значение структурного типа.
			Возврат СтруктурныйОбъектВОбъектXDTO(ЗначениеТипа);
		Иначе
			Возврат ФабрикаXDTO.Создать(ТипXDTO, ЗначениеТипа); // Например, UUID.
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Получает платформенный аналог значения XDTO-типа.
//
// Параметры:
// ЗначениеXDTO - Значение произвольного XDTO-типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеXDTOВЗначениеТипа(ЗначениеXDTO)
	
	Если ТипЗнч(ЗначениеXDTO) = Тип("ЗначениеXDTO") Тогда
		Возврат ЗначениеXDTO.Значение;
	ИначеЕсли ТипЗнч(ЗначениеXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат ОбъектXDTOВСтруктурныйОбъект(ЗначениеXDTO);
	Иначе
		Возврат ЗначениеXDTO;
	КонецЕсли;
	
КонецФункции

// Заполняет область поставляемыми данными при подготовке к использованию
//
// Параметры:
//   ОбластьДанных - номер заполняемой области
//   ИДФайлаВыгрузки - ид файла начальных данных
//   Вариант - вариант начальных данных
//   РежимИспользования - демо или рабочий
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка"
//
Функция ЗагрузитьОбластьИзПоставляемыхДанных(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, Знач Вариант, СообщениеОФатальнойОшибке)
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	ФайлДанныхНайден = Ложь;
	
	Фильтр = Новый Массив();
	Фильтр.Добавить(Новый Структура("Код, Значение", "ИмяКонфигурации", Метаданные.Имя));
	Фильтр.Добавить(Новый Структура("Код, Значение", "ВерсияКонфигурации", Метаданные.Версия));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Вариант", Вариант));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Режим", 
		?(Константы.РежимИспользованияИнформационнойБазы.Получить() 
			= Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный, 
			"Демонстрационный", "Рабочий")));

	Дескриптор = ПоставляемыеДанные.ДескрипторПоставляемыхДанныхИзКэша(ИДФайлаВыгрузки);
	Если Дескриптор <> Неопределено Тогда
		Если ПоставляемыеДанные.ХарактеристикиСовпадают(Фильтр, Дескриптор.Характеристики) Тогда
			ДанныеЭталона = ПоставляемыеДанные.ПоставляемыеДанныеИзКэша(ИДФайлаВыгрузки);
			ИмяФайлаВыгрузки = ПолучитьИмяВременногоФайла();
			ДанныеЭталона.Записать(ИмяФайлаВыгрузки);
			ФайлДанныхНайден = Истина;
		Иначе
			СообщениеОФатальнойОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Указанный файл начальных данных не подходит для данной конфигурации.
			|Дескриптор файла: %1'"),
			ПоставляемыеДанные.ПолучитьОписаниеДанных(Дескриптор));
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
	КонецЕсли;
	
	Если Не ФайлДанныхНайден Тогда
	
		Дескрипторы = ПоставляемыеДанные.ДескрипторыПоставляемыхДанныхИзМенеджера("ЭталонОбластиДанных", Фильтр);
	
		Если Дескрипторы.Descriptor.Количество() = 0 Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'В менеджере сервиса нет файла начальных данных для текущей версии конфигурации.'");
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
		
		Если Дескрипторы.Descriptor[0].FileGUID <> ИДФайлаВыгрузки Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'Файл начальных данных, имеющийся в менеджере сервиса, отличается от указанного в сообщении на подготовку области. Область не может быть подготовлена.'");
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
		
		ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
			
		Если ИмяФайлаВыгрузки = Неопределено Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'В менеджере сервиса больше нет требуемого файла начальных данных, вероятно он был заменен. Область не может быть подготовлена.'");
			Возврат Ложь;
		КонецЕсли;
		
		ПоставляемыеДанные.СохранитьПоставляемыеДанныеВКэш(Дескрипторы.Descriptor[0], ИмяФайлаВыгрузки);
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Попытка
		ОбщегоНазначения.ЗаблокироватьИБ();
		ВыгрузкаЗагрузкаДанных.ЗагрузитьТекущуюОбластьИзАрхива(ИмяФайлаВыгрузки);
		ОбщегоНазначения.РазблокироватьИБ();
	Исключение
		ОбщегоНазначения.РазблокироватьИБ();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Копирование области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
		КонецПопытки;
		
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
	КонецПопытки;
	
	Возврат "Успех";

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных

// Вызывается при проверке доступности неразделенных данных для записи.
//
Процедура КонтрольНеразделенныхДанныхПриЗаписи(Знач Источник)
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		ПредставлениеИсключения = НСтр("ru = 'Нарушение прав доступа!'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
		
		ЗаписьЖурналаРегистрации(
			ПредставлениеИсключения,
			УровеньЖурналаРегистрации.Ошибка,
			Источник.Метаданные());
		
		ВызватьИсключение ПредставлениеИсключения;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области

// Выполняет обработку значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта,
//  Записать - Булево, признак выполнения записи значения ссылочного типа,
//  Удалить - Булево, признак выполнения удаления значения ссылочного типа.
//
Процедура ОбработатьВспомогательныеДанные(ОбъектВспомогательныхДанных, Знач Записать, Знач Удалить)
	
	Попытка
		
		ТребуетсяВосстановлениеРазделенияСеанса = Ложь;
		
		Если ТипЗнч(ОбъектВспомогательныхДанных) = Тип("УдалениеОбъекта") Тогда
			ПроверяемоеЗначение = ОбъектВспомогательныхДанных.Ссылка;
			ПроверяетсяСсылка = Истина;
		Иначе
			ПроверяемоеЗначение = ОбъектВспомогательныхДанных;
			ПроверяетсяСсылка = Ложь;
		КонецЕсли;
		
		Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(ПроверяемоеЗначение.Метаданные(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			Если ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
				
				// В разделенном сеансе достаточно просто выполнить запись объекта
				Если Записать Тогда
					ОбъектВспомогательныхДанных.Записать();
				КонецЕсли;
				Если Удалить Тогда
					ОбъектВспомогательныхДанных.Удалить();
				КонецЕсли;
				
			Иначе
				
				// В неразделенном сеансе требуется переключение разделения сеанса для избежания
				// конфликта блокировок с сеансами, в которых установлено другое значение разделителя.
				Если ПроверяетсяСсылка Тогда
					ЗначениеРазделителя = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ПроверяемоеЗначение, ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных());
				Иначе
					ЗначениеРазделителя = ОбъектВспомогательныхДанных[ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()];
				КонецЕсли;
				ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ЗначениеРазделителя);
				ТребуетсяВосстановлениеРазделенияСеанса = Истина;
				Если Записать Тогда
					ОбъектВспомогательныхДанных.Записать();
				КонецЕсли;
				Если Удалить Тогда
					ОбъектВспомогательныхДанных.Удалить();
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Если Записать Тогда
				ОбъектВспомогательныхДанных.Записать();
			КонецЕсли;
			Если Удалить Тогда
				ОбъектВспомогательныхДанных.Удалить();
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТребуетсяВосстановлениеРазделенияСеанса Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
	Исключение
		
		Если ТребуетсяВосстановлениеРазделенияСеанса Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы

// Дополнительные действия, выполняемые при изменении разделения сеанса.
//
Процедура ПриИзмененииОбластиДанных() Экспорт
	
	ОчиститьВсеПараметрыСеансаКромеРазделителей();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ПОЛУЧЕНИЯ ПОСТАВЛЯЕМЫХ ДАННЫХ

// Регистрирует обработчики поставляемых данных за день и за все время
//
Процедура ЗарегистрироватьОбработчикиПоставляемыхДанных(Знач Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ВидДанных = "ЭталонОбластиДанных";
	Обработчик.КодОбработчика = "ЭталонОбластиДанных";
	Обработчик.Обработчик = РаботаВМоделиСервиса;
	
КонецПроцедуры

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать
// 
// Параметры:
//   Дескриптор   - ОбъектXDTO Descriptor.
//   Загружать    - булево, возвращаемое
//
Процедура ДоступныНовыеДанные(Знач Дескриптор, Загружать) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Характеристика.Code = "ИмяКонфигурации" И Характеристика.Value = Метаданные.Имя Тогда
				Загружать = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
		
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO Дескриптор.
//   ПутьКФайлу   - Строка или Неопределено. Полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры. Если в менеджере сервиса не был
//                  указан файл - значение аргумента равно Неопределено.
//
Процедура ОбработатьНовыеДанные(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		ОбработатьПоставляемыйЭталонКонфигурации(Дескриптор, ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Вызывается при отмене обработки данных в случае сбоя
//
Процедура ОбработкаДанныхОтменена(Знач Дескриптор) Экспорт 
	
КонецПроцедуры

Процедура ОбработатьПоставляемыйЭталонКонфигурации(Знач Дескриптор, Знач ПутьКФайлу)
	
	Если ЗначениеЗаполнено(ПутьКФайлу) Тогда
		
		ПоставляемыеДанные.СохранитьПоставляемыеДанныеВКэш(Дескриптор, ПутьКФайлу);
		
	Иначе
		
		Фильтр = Новый Массив;
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Характеристика.IsKey Тогда
				Фильтр.Добавить(Новый Структура("Код, Значение", Характеристика.Code, Характеристика.Value));
			КонецЕсли;
		КонецЦикла;

		Для каждого Ссылка Из ПоставляемыеДанные.СсылкиПоставляемыхДанныхИзКэша(Дескриптор.DataType, Фильтр) Цикл
		
			ПоставляемыеДанные.УдалитьПоставляемыеДанныеИзКэша(Ссылка);
		
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

// Переносит данные из РС УдалитьОбластиДанных в РС ОбластиДанных
//
Процедура ПеренестиОбластиДанных() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ЕСТЬNULL(ОбластиДанных.ОбластьДанныхВспомогательныеДанные, УдалитьОбластиДанных.ОбластьДанных) КАК ОбластьДанныхВспомогательныеДанные,
		|	УдалитьОбластиДанных.Представление,
		|	ЕСТЬNULL(ОбластиДанных.Статус, УдалитьОбластиДанных.Статус) КАК Статус,
		|	УдалитьОбластиДанных.Префикс,
		|	ЕСТЬNULL(ОбластиДанных.Повтор, УдалитьОбластиДанных.Повтор) КАК Повтор,
		|	УдалитьОбластиДанных.ЧасовойПояс,
		|	ЕСТЬNULL(ОбластиДанных.ИдентификаторВыгрузки, УдалитьОбластиДанных.ИдентификаторВыгрузки) КАК ИдентификаторВыгрузки,
		|	ЕСТЬNULL(ОбластиДанных.ОшибкаОбработки, УдалитьОбластиДанных.ОшибкаОбработки) КАК ОшибкаОбработки,
		|	ЕСТЬNULL(ОбластиДанных.Вариант, УдалитьОбластиДанных.Вариант) КАК Вариант
		|ИЗ
		|	РегистрСведений.УдалитьОбластиДанных КАК УдалитьОбластиДанных
		|		ПОЛНОЕ СОЕДИНЕНИЕ РегистрСведений.ОбластиДанных КАК ОбластиДанных
		|		ПО УдалитьОбластиДанных.ОбластьДанных = ОбластиДанных.ОбластьДанныхВспомогательныеДанные";		Запрос = Новый Запрос(ТекстЗапроса);
		ТаблицаПереноса = Запрос.Выполнить().Выгрузить();
		
		Для Каждого Перенос Из ТаблицаПереноса Цикл
			
			Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
			Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
			Менеджер.Прочитать();
			Если Не Менеджер.Выбран() Тогда
				ЗаполнитьЗначенияСвойств(Менеджер, Перенос);
				Менеджер.Записать();
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.Представление) Тогда
				
				Менеджер = Константы.ПредставлениеОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.Представление;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.Префикс) Тогда
				
				Менеджер = Константы.ПрефиксОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.Префикс;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.ЧасовойПояс) Тогда
				
				Менеджер = Константы.ЧасовойПоясОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.ЧасовойПояс;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Отключает для пользователей информационной базы использование разделителя
// ОбластьДанныхВспомогательныеДанные.
//
Процедура ОтключитьРазделениеПользователейПоРазделителюВнутреннихДанных() Экспорт
	
	ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Для Каждого ПользовательИБ Из ПользователиИБ Цикл
		
		Если ПользовательИБ.РазделениеДанных.Свойство(РазделительВспомогательныхДанных()) Тогда
			ПользовательИБ.РазделениеДанных.Удалить(РазделительВспомогательныхДанных());
			ПользовательИБ.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет контроль структуры метаданных по критерию недоступности неразделенных данных
// для записи из сеансов с включенным разделением.
//
Процедура КонтрольНеразделенныхДанныхПриОбновлении() Экспорт
	
	ПравилаКонтроляМетаданных = Новый Соответствие;
	
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Константы, "КонстантаМенеджерЗначения.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Справочники, "СправочникОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Документы, "ДокументОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.БизнесПроцессы, "БизнесПроцессОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Задачи, "ЗадачаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовРасчета, "ПланВидовРасчетаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовХарактеристик, "ПланВидовХарактеристикОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыОбмена, "ПланОбменаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыСчетов, "ПланСчетовОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыБухгалтерии, "РегистрБухгалтерииНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыНакопления, "РегистрНакопленияНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыРасчета, "РегистрРасчетаНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыСведений, "РегистрСведенийНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегламентныеЗадания);
	
	Исключения = Новый Массив();
	
	Исключения.Добавить(Метаданные.РегистрыСведений.КэшПрограммныхИнтерфейсов);
	Исключения.Добавить(Метаданные.Константы.БлокировкаОтправкиБыстрыхСообщений);
	Исключения.Добавить(Метаданные.РегистрыСведений.НеразделенныеПользователи);
	
	// СтандартныеПодсистемы.ОбменДанными
	Исключения.Добавить(Метаданные.РегистрыСведений.НастройкиТранспортаОбмена);
	Исключения.Добавить(Метаданные.РегистрыСведений.СостоянияОбменовДанными);
	Исключения.Добавить(Метаданные.РегистрыСведений.СостоянияУспешныхОбменовДанными);
	// Конец СтандартныеПодсистемы.ОбменДанными
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ОценкаПроизводительности") Тогда
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыВремени"));
	КонецЕсли;
	
	СтандартныеРазделители = Новый Массив;
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные);
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные);
	
	КонтрольныеПроцедуры = Новый Массив;
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхНаборовЗаписейПриЗаписи.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхОбъектовПриЗаписи.Обработчик);
	
	КонтролирующиеПодписки = Новый Массив;
	Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
		Если КонтрольныеПроцедуры.Найти(ПодпискаНаСобытие.Обработчик) <> Неопределено Тогда
			КонтролирующиеПодписки.Добавить(ПодпискаНаСобытие);
		КонецЕсли;
	КонецЦикла;
	
	НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки = Новый Массив();
	НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями = Новый Массив();
	
	Для Каждого ПравилоКонтроляМетаданных Из ПравилаКонтроляМетаданных Цикл
		
		КонтролируемыеОбъектыМетаданных = ПравилоКонтроляМетаданных.Ключ;
		КонструкторТипаОбъектовМетаданных = ПравилоКонтроляМетаданных.Значение;
		
		Для Каждого КонтролируемыйОбъектМетаданных Из КонтролируемыеОбъектыМетаданных Цикл
			
			// 1. Проверка объекта метаданных на разделение несколькими разделителями
			
			ЧислоРазделителей = 0;
			Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
				Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
					ЧислоРазделителей = ЧислоРазделителей + 1;
				КонецЕсли;
			КонецЦикла;
			
			Если ЧислоРазделителей > 1 Тогда
				НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Добавить(КонтролируемыйОбъектМетаданных);
			КонецЕсли;
			
			// 2. Проверка неразделенных объектов метаданных на включение в состав контролирующих
			// подписок на события
			
			Если ЗначениеЗаполнено(КонструкторТипаОбъектовМетаданных) Тогда
				
				Если Исключения.Найти(КонтролируемыйОбъектМетаданных) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				ТипОбъектаМетаданных = Тип(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					КонструкторТипаОбъектовМетаданных, КонтролируемыйОбъектМетаданных.Имя));
				
				ТребуетсяКонтроль = Истина;
				Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
					
					Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
						
						ТребуетсяКонтроль = Ложь;
						
					КонецЕсли;
					
				КонецЦикла;
				
				ОбеспеченКонтроль = Ложь;
				Если ТребуетсяКонтроль Тогда
					
					Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
						
						Если КонтролирующаяПодписка.Источник.СодержитТип(ТипОбъектаМетаданных) Тогда
							ОбеспеченКонтроль = Истина;
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				Если ТребуетсяКонтроль И Не ОбеспеченКонтроль Тогда
					НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Добавить(КонтролируемыйОбъектМетаданных);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВызываемыеИсключения = Новый Массив();
	
	ТекстРазделителей = "";
	Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
		
		Если Не ПустаяСтрока(ТекстРазделителей) Тогда
			ТекстРазделителей = ТекстРазделителей + ", ";
		КонецЕсли;
		
		ТекстРазделителей = ТекстРазделителей + СтандартныйРазделитель.Имя;
		
	КонецЦикла;
	
	Если НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		Для Каждого НеконтролируемыйОбъектМетаданных Из НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НеконтролируемыйОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ТекстПодписок = "";
		Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстПодписок) Тогда
				ТекстПодписок = ТекстПодписок + ", ";
			КонецЕсли;
			
			ТекстПодписок = ТекстПодписок + КонтролирующаяПодписка.Имя;
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных, не входящие в состав разделителей БСП (%1),
                  |должны быть включены в состав подписок на события (%2), контролирующих
                  |невозможность записи неразделенных данных в разделенных сеансах.
                  |Следующие объекты метаданных не удовлетворяют этому критерию: %3.'"),
			ТекстРазделителей, ТекстПодписок, ТекстИсключения));
		
	КонецЕсли;
	
	Если НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		
		Для Каждого НарушающийОбъектМетаданных Из НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НарушающийОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных конфигурации должны быть разделены не более чем одним разделителем БСП (%1).
                  |Следующие объекты не удовлетворяют этому критерию: %2'"),
			ТекстРазделителей, ТекстИсключения));
		
	КонецЕсли;
	
	РезультирующееИсключение = "";
	Итератор = 1;
	
	Для Каждого ВызываемоеИсключение Из ВызываемыеИсключения Цикл
		
		Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
			РезультирующееИсключение = РезультирующееИсключение + Символы.ПС + Символы.ВК;
		КонецЕсли;
		
		РезультирующееИсключение = РезультирующееИсключение + Формат(Итератор, "ЧДЦ=0; ЧГ=0") + ". " + ВызываемоеИсключение;
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
		
		РезультирующееИсключение = НСтр("ru = 'Обнаружены ошибки в структуре метаданных конфигурации:'") + Символы.ПС + Символы.ВК + РезультирующееИсключение;
		ВызватьИсключение РезультирующееИсключение;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет контроль структуры метаданных по критерию  упорядоченности общих реквизитов
// в дереве метаданных конфигурации.
//
Процедура КонтрольРазделителейПриОбновлении() Экспорт
	
	ПорядокПрикладныхДанных = 99;
	ПорядокВнутреннихДанных = 99;
	
	РазделительПрикладной = Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные;
	РазделительВнутренний = Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные;
	
	Итератор = 0;
	Для Каждого ОбщийРеквизитКонфигурации Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если ОбщийРеквизитКонфигурации = РазделительПрикладной Тогда
			ПорядокПрикладныхДанных = Итератор;
		ИначеЕсли ОбщийРеквизитКонфигурации = РазделительВнутренний Тогда
			ПорядокВнутреннихДанных = Итератор;
		КонецЕсли;
		
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если ПорядокПрикладныхДанных <= ПорядокВнутреннихДанных Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обнаружено нарушение структуры метаданных конфигурации: общий реквизит %1 должен
                  |быть расположен в дереве метаданных конфигурации до общего реквизита
                  |%2 по порядку!'"),
			РазделительВнутренний.Имя,
			РазделительПрикладной.Имя);
		
	КонецЕсли;
	
КонецПроцедуры

