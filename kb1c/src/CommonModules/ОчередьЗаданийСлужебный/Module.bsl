////////////////////////////////////////////////////////////////////////////////
// ОчередьЗаданий: Работа с очередью заданий
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Рассчитывает следующий момент запуска задания. 
// 
// Параметры: 
// Расписание                  - РасписаниеРегламентногоЗадания - расписание, 
//                               для которого требуется рассчитать момент следующего запуска.
// ЧасовойПояс				   - Строка.
// ДатаНачалаПоследнегоЗапуска - Дата - Дата начала последнего запуска регламентного задания. 
//                               Если дата задана, то используется для проверки таких условий как 
//                               ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня. 
//                               Если дата не задана, то считается, 
//                               что задание не выполнялось ни разу и проверка этих условий не производится.
// 
// Возвращаемое значение: 
// Дата - Рассчитанный следующий момент запуска задания. 
// 
Функция ПолучитьЗапланированныйМоментЗапускаЗадания(Знач Расписание, Знач ЧасовойПояс, 
		Знач ДатаНачалаПоследнегоЗапуска = '00010101', Знач ДатаЗавершенияПоследнегоЗапуска = '00010101') Экспорт
	
	Если ПустаяСтрока(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда 
		ДатаНачалаПоследнегоЗапуска = МестноеВремя(ДатаНачалаПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) Тогда
		ДатаЗавершенияПоследнегоЗапуска = МестноеВремя(ДатаЗавершенияПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	ДатаРасчета = МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПояс);
	
	НайденнаяДата = СледующаяДатаВыполненияРасписания(Расписание, ДатаРасчета, ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска);
	
	Если ЗначениеЗаполнено(НайденнаяДата) Тогда
		Возврат УниверсальноеВремя(НайденнаяДата, ЧасовойПояс);
	Иначе
		Возврат НайденнаяДата;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Объявление служебных событий, к которым можно подключать обработчики БСП.

// Объявляет события подсистемы ОчередьЗаданий:
//
// Серверные события:
//   ПриПолученииСпискаШаблонов
//   ПриОпределенииПсевдонимовОбработчиков
//   ПриОпределенииОбработчиковОшибок
//   ПриОпределенииИспользованияРегламентныхЗаданий
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Формирует список шаблонов заданий очереди.
	//
	// Параметры:
	//  Шаблоны - Массив строк. В параметр следует добавить имена предопределенных
	//   неразделенных регламентных заданий, которые должны использоваться в качестве
	//   шаблонов для заданий очереди.
	//
	// Синтаксис:
	// Процедура ПриПолученииСпискаШаблонов(Шаблоны) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ЗаполнитьСписокРазделенныхРегламентныхЗаданий).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриПолученииСпискаШаблонов");
	
	// Заполняет соответствие имен методов их псевдонимам для вызова из очереди заданий
	//
	// Параметры:
	//  СоответствиеИменПсевдонимам - Соответствие
	//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных
	//   Значение - Имя метода для вызова, например РаботаВМоделиСервиса.ОчиститьОбластьДанных
	//    В качестве значения можно указать Неопределено, в этом случае считается что имя 
	//    совпадает с псевдонимом
	//
	// Синтаксис:
	// Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ПолучитьРазрешенныеМетодыОчередиЗаданий).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииПсевдонимовОбработчиков");
		
	// Заполняет соответствие методов обработчиков ошибок псевдонимам методов, при возникновении
	// ошибок в которых они вызываются.
	//
	// Параметры:
	//  ОбработчикиОшибок - Соответствие
	//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных
	//   Значение - Имя метода - обработчика ошибок, для вызова при возникновении ошибки. 
	//    Обработчик ошибок вызывается в случае завершения выполнения исходного задания
	//    с ошибкой. Обработчик ошибок вызывается в той же области данных, что и исходное
	//    задание.
	//    Метод обработчика ошибок считается разрешенным к вызову механизмами очереди. 
	//    Параметры обработчика ошибок:
	//     ПараметрыЗадания - Структура - параметры задания очереди
	//      Параметры
	//      НомерПопытки
	//      КоличествоПовторовПриАварийномЗавершении
	//      ДатаНачалаПоследнегоЗапуска
	//     ИнформацияОбОшибке - ИнформацияОбОшибке - описание ошибки, произошедшей при
	//      выполнении задания
	//
	// Синтаксис:
	// Процедура ПриОпределенииОбработчиковОшибок(ОбработчикиОшибок) Экспорт
	//
	// (То же, что ОчередьЗаданийПереопределяемый.ПриОпределенииОбработчиковОшибок).
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииОбработчиковОшибок");
	
	// Формирует таблицу регламентных заданий с признаком использования в модели сервиса
	//
	// Параметры:
	// ТаблицаИспользования - ТаблицаЗначений - таблица, которую необходимо
	//  заполнить регламентными заданиями и признаком использования, колонки:
	//  РегламентноеЗадание - Строка - имя предопределенного регламентного задания
	//  Использование - Булево - Истина, если регламентное задание должно
	//   выполняться в модели сервиса. Ложь - если не должно.
	//
	// Синтаксис:
	// Процедура ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования) Экспорт
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
		"ОчередьЗаданийСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриВключенииРазделенияПоОбластямДанных"].Добавить(
		"ОчередьЗаданийСлужебный");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаДанных\ПриОпределенииОбъектовМетаданныхИсключаемыхИзВыгрузкиЗагрузки"].Добавить(
			"ОчередьЗаданийСлужебный");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП

// Вызывается при включении разделения данных по областям данных.
//
Процедура ПриВключенииРазделенияПоОбластямДанных() Экспорт
	
	УстановитьИспользованиеРегламентныхЗаданий();
	
	Если Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Получить() = 0 Тогда
		Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Установить(600);
	КонецЕсли;
	
	Если Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить() = 0 Тогда
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Установить(1);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик, вызываемый при определении объектов метаданных, не переносящихся между моделями при выгрузке / загрузке данных.
//
// Параметры
//  Объекты - Массив(ОбъектМетаданных).
//
Процедура ПриОпределенииОбъектовМетаданныхИсключаемыхИзВыгрузкиЗагрузки(Объекты) Экспорт
	
	Объекты.Добавить(Метаданные.Справочники.ОчередьЗаданий);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// Экспортные служебные процедуры и функции

// Производит планирование выполнения заданий из РС ОчередьЗаданий 
// 
Процедура ПланированиеОбработкиЗаданий() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяПользователя()) Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	// Выбираем события в состояниях Выполняется, Завершено, НеЗапланировано, ОшибкаВыполнения
	Запрос = Новый Запрос;
	
	СправочникиЗаданий = ОчередьЗаданийСлужебныйПовтИсп.ПолучитьСправочникиЗаданий();
	ТекстЗапроса = "";
	Для Каждого СправочникЗаданий Из СправочникиЗаданий Цикл
		
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|"
			
		КонецЕсли;
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(СправочникЗаданий.СоздатьЭлемент().Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	Очередь.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	ЕСТЬNULL(Очередь.Шаблон, НЕОПРЕДЕЛЕНО) КАК Шаблон,
			|	ЕСТЬNULL(ЧасовыеПояса.Значение, """") КАК ЧасовойПояс,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.Расписание
			|		ИНАЧЕ Очередь.Шаблон.Расписание
			|	КОНЕЦ КАК Расписание,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.КоличествоПовторовПриАварийномЗавершении
			|		ИНАЧЕ Очередь.Шаблон.КоличествоПовторовПриАварийномЗавершении
			|	КОНЕЦ КАК КоличествоПовторовПриАварийномЗавершении,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.ИнтервалПовтораПриАварийномЗавершении
			|		ИНАЧЕ Очередь.Шаблон.ИнтервалПовтораПриАварийномЗавершении
			|	КОНЕЦ КАК ИнтервалПовтораПриАварийномЗавершении
			|ИЗ
			|	%1 КАК Очередь
			|		ЛЕВОЕ СОЕДИНЕНИЕ Константа.ЧасовойПоясОбластиДанных КАК ЧасовыеПояса
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = ЧасовыеПояса.ОбластьДанныхВспомогательныеДанные
			|ГДЕ
			|	Очередь.СостояниеЗадания В (ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Выполняется), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Завершено), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.НеЗапланировано), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.ОшибкаВыполнения))"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		Иначе
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	-1 КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	НЕОПРЕДЕЛЕНО КАК Шаблон,
			|	"""" КАК ЧасовойПояс,
			|	Очередь.Расписание КАК Расписание,
			|	Очередь.КоличествоПовторовПриАварийномЗавершении КАК КоличествоПовторовПриАварийномЗавершении,
			|	Очередь.ИнтервалПовтораПриАварийномЗавершении КАК ИнтервалПовтораПриАварийномЗавершении
			|ИЗ
			|	%1 КАК Очередь
			|ГДЕ
			|	Очередь.СостояниеЗадания В (ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Выполняется), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Завершено), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.НеЗапланировано), ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.ОшибкаВыполнения))"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		КонецЕсли;
		
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	Результат = ОбщегоНазначения.ВыполнитьЗапросВнеТранзакции(Запрос);
	Выборка = Результат.Выбрать();
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
	Иначе
		МодульРаботаВМоделиСервиса = Неопределено;
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		Исключение
			// Запись заблокирована, перейти к следующей
			Продолжить;
		КонецПопытки;
		
		// Проверка блокировки области
		Если МодульРаботаВМоделиСервиса <> Неопределено
			И Выборка.ОбластьДанных <> -1 
			И МодульРаботаВМоделиСервиса.ОбластьДанныхЗаблокирована(Выборка.ОбластьДанных) Тогда
			
			// Область заблокирована, перейти к следующей записи
			Продолжить;
		КонецЕсли;
		
		// Перепланируем завершившиеся регламентные задания и аварийно завершившиеся фоновые, удаляем выполненные фоновые
		ЗапланироватьЗадание(Выборка);
		
	КонецЦикла;

	// Вычисление количество требуемых исполняющих фоновых заданий
	КоличествоЗапускаемыхФоновыхЗаданий = КоличествоИсполняющихФоновыхЗаданийКЗапуску();
	
	// Запуск исполняющих фоновых заданий
	ЗапуститьИсполняющееФоновоеЗадание(КоличествоЗапускаемыхФоновыхЗаданий);
	
КонецПроцедуры

// Процедура выполняет задания из РС ОчередьЗаданий 
// 
// Параметры: 
// КлючФоновогоЗадания - УникальныйИдентификатор - ключ необходим 
//                       для поиска текущего фонового задания.
//
Процедура ОбработатьОчередьЗаданий(КлючФоновогоЗадания) Экспорт
	
	Если ПустаяСтрока(ИмяПользователя()) Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	НайденноеФоновоеЗадание = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Ключ", КлючФоновогоЗадания));
	Если НайденноеФоновоеЗадание.Количество() = 1 Тогда
		ИсполняющееФоновоеЗадание = НайденноеФоновоеЗадание[0];
	Иначе
		Возврат;
	КонецЕсли;
	
	МожноВыполнять = Истина;
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания = 
		Константы.МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания.Получить();
	МаксимальноеКоличествоИсполняющихФоновыхЗаданий =
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить();
	
	Запрос = Новый Запрос;
	
	СправочникиЗаданий = ОчередьЗаданийСлужебныйПовтИсп.ПолучитьСправочникиЗаданий();
	ТекстЗапроса = "";
	Для Каждого СправочникЗаданий Из СправочникиЗаданий Цикл
		
		ПерваяСтрока = ПустаяСтрока(ТекстЗапроса);
		
		Если Не ПерваяСтрока Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|"
			
		КонецЕсли;
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(СправочникЗаданий.СоздатьЭлемент().Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	Очередь.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	Очередь.Использование,
			|	Очередь.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
			|	Очередь.СостояниеЗадания,
			|	Очередь.ИсполняющееФоновоеЗадание,
			|	Очередь.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
			|	Очередь.НомерПопытки,
			|	Очередь.Шаблон КАК Шаблон,
			|	ЕСТЬNULL(Очередь.Шаблон.Ссылка, НЕОПРЕДЕЛЕНО) КАК СсылкаШаблона,
			|	ЕСТЬNULL(ЧасовыеПояса.Значение, """") КАК ЧасовойПояс,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.Расписание
			|		ИНАЧЕ Очередь.Шаблон.Расписание
			|	КОНЕЦ КАК Расписание,
			|	ВЫБОР
			|		КОГДА Очередь.Шаблон = ЗНАЧЕНИЕ(Справочник.ШаблоныЗаданийОчереди.ПустаяСсылка)
			|			ТОГДА Очередь.ИмяМетода
			|		ИНАЧЕ Очередь.Шаблон.ИмяМетода
			|	КОНЕЦ КАК ИмяМетода,
			|	Очередь.Параметры,
			|	Очередь.ДатаНачалаПоследнегоЗапуска,
			|	Очередь.ДатаЗавершенияПоследнегоЗапуска
			|ИЗ %1 КАК ОЧЕРЕДЬ ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.БлокировкиСеансовОбластейДанных КАК Блокировки
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = Блокировки.ОбластьДанныхВспомогательныеДанные
			|		ЛЕВОЕ СОЕДИНЕНИЕ Константа.ЧасовойПоясОбластиДанных КАК ЧасовыеПояса
			|		ПО Очередь.ОбластьДанныхВспомогательныеДанные = ЧасовыеПояса.ОбластьДанныхВспомогательныеДанные
			|ГДЕ
			|	Очередь.Использование
			|	И Очередь.ЗапланированныйМоментЗапуска <= &ТекущаяУниверсальнаяДата
			|	И Очередь.СостояниеЗадания = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Запланировано)
			|	И (Очередь.ЭксклюзивноеВыполнение
			|			ИЛИ Блокировки.ОбластьДанныхВспомогательныеДанные ЕСТЬ NULL 
			|			ИЛИ Блокировки.НачалоБлокировки > &ТекущаяУниверсальнаяДата
			|			ИЛИ Блокировки.КонецБлокировки < &ТекущаяУниверсальнаяДата)"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		Иначе
			
			ТекстЗапроса = ТекстЗапроса + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ВЫБРАТЬ
			|	-1 КАК ОбластьДанных,
			|	Очередь.Ссылка КАК Идентификатор,
			|	Очередь.Использование,
			|	Очередь.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
			|	Очередь.СостояниеЗадания,
			|	Очередь.ИсполняющееФоновоеЗадание,
			|	Очередь.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
			|	Очередь.НомерПопытки,
			|	НЕОПРЕДЕЛЕНО КАК Шаблон,
			|	НЕОПРЕДЕЛЕНО КАК СсылкаШаблона,
			|	"""" КАК ЧасовойПояс,
			|	Очередь.Расписание КАК Расписание,
			|	Очередь.ИмяМетода КАК ИмяМетода,
			|	Очередь.Параметры,
			|	Очередь.ДатаНачалаПоследнегоЗапуска,
			|	Очередь.ДатаЗавершенияПоследнегоЗапуска
			|ИЗ %1 КАК ОЧЕРЕДЬ
			|ГДЕ
			|	Очередь.Использование
			|	И Очередь.ЗапланированныйМоментЗапуска <= &ТекущаяУниверсальнаяДата
			|	И Очередь.СостояниеЗадания = ЗНАЧЕНИЕ(Перечисление.СостоянияЗаданий.Запланировано)"
			, СправочникЗаданий.ПустаяСсылка().Метаданные().ПолноеИмя());
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ 111
	|	ВложенныйЗапрос.ОбластьДанных,
	|	ВложенныйЗапрос.Идентификатор КАК Идентификатор,
	|	ВложенныйЗапрос.Использование,
	|	ВложенныйЗапрос.ЗапланированныйМоментЗапуска КАК ЗапланированныйМоментЗапуска,
	|	ВложенныйЗапрос.ИсполняющееФоновоеЗадание,
	|	ВложенныйЗапрос.ЭксклюзивноеВыполнение КАК ЭксклюзивноеВыполнение,
	|	ВложенныйЗапрос.НомерПопытки,
	|	ВложенныйЗапрос.Шаблон,
	|	ВложенныйЗапрос.СсылкаШаблона,
	|	ВложенныйЗапрос.ЧасовойПояс,
	|	ВложенныйЗапрос.Расписание,
	|	ВложенныйЗапрос.ИмяМетода,
	|	ВложенныйЗапрос.Параметры,
	|	ВложенныйЗапрос.ДатаНачалаПоследнегоЗапуска,
	|	ВложенныйЗапрос.ДатаЗавершенияПоследнегоЗапуска
	|ИЗ
	|	(" +  ТекстЗапроса + ") КАК ВложенныйЗапрос
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЭксклюзивноеВыполнение УБЫВ,
	|	ЗапланированныйМоментЗапуска,
	|	Идентификатор";
	
	Запрос.Текст = ТекстЗапроса;
	РазмерВыборкиТекст = Формат(МаксимальноеКоличествоИсполняющихФоновыхЗаданий * 3, "ЧН=; ЧГ=");
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "111", РазмерВыборкиТекст);
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
	Иначе
		МодульРаботаВМоделиСервиса = Неопределено;
	КонецЕсли;
	
	Пока МожноВыполнять Цикл 
		Запрос.УстановитьПараметр("ТекущаяУниверсальнаяДата", ТекущаяУниверсальнаяДата());
		
		Выборка = ОбщегоНазначения.ВыполнитьЗапросВнеТранзакции(Запрос).Выбрать();
		
		БлокировкаУстановлена = Ложь;
		Пока Выборка.Следующий() Цикл 
			Попытка
				
				ЗаблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
				
				// Проверка блокировки области
				Если МодульРаботаВМоделиСервиса <> Неопределено
					И Выборка.ОбластьДанных <> -1 
					И МодульРаботаВМоделиСервиса.ОбластьДанныхЗаблокирована(Выборка.ОбластьДанных) Тогда
					
					РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
					
					// Область заблокирована, перейти к следующей записи
					Продолжить;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(Выборка.Шаблон)
						И Выборка.СсылкаШаблона = Неопределено Тогда
					
					ШаблонСообщения = НСтр("ru = 'На найден шаблон задания очереди с идентификатором %1'", 
						Метаданные.ОсновнойЯзык.КодЯзыка);
					ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Выборка.Шаблон);
					ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий. Выполнение'", 
						ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
						УровеньЖурналаРегистрации.Ошибка,
						,
						,
						ТекстСообщения);
					
					РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
					Продолжить;
				КонецЕсли;
				
				БлокировкаУстановлена = Истина;
				Прервать;
			Исключение
				// Не удалось установить блокировку
			КонецПопытки;
		КонецЦикла;
		
		Если Не БлокировкаУстановлена Тогда 
			Возврат;
		КонецЕсли;
		
		Расписание = Выборка.Расписание.Получить();
		Если Расписание <> Неопределено Тогда
			// Проверка попадания в допустимые интервалы очереди
			ЧасовойПояс = Выборка.ЧасовойПояс;
			
			Если ПустаяСтрока(ЧасовойПояс) Тогда
				ЧасовойПояс = Неопределено;
			КонецЕсли;
			
			ВремяОбласти = МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПояс);
			Просрочено = НЕ Расписание.ТребуетсяВыполнение(ВремяОбласти);
		Иначе
			Просрочено = Ложь;
		КонецЕсли;
		
		Если Просрочено Тогда
			// Требуется перепланировать задание
			НачатьТранзакцию();
			Попытка
				Блокировка = Новый БлокировкаДанных;
				ЭлементБлокировки = Блокировка.Добавить(Выборка.Идентификатор.Метаданные().ПолноеИмя());
				ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Идентификатор);
				
				Если Выборка.ОбластьДанных <> -1 Тогда
					ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, Выборка.ОбластьДанных);
				КонецЕсли;
				Блокировка.Заблокировать();
				
				Задание = Выборка.Идентификатор.ПолучитьОбъект();
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.НеЗапланировано;
				Задание.Записать();
				ЗафиксироватьТранзакцию();
			Исключение
				ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		Иначе
			ВыполнитьЗаданиеОчереди(Выборка.Идентификатор, ИсполняющееФоновоеЗадание, Выборка.Шаблон, Выборка.ИмяМетода);
		КонецЕсли;
		
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		
		// Проверка возможности дальнейшего выполнения
		ДлительностьВыполнения = ТекущаяУниверсальнаяДата() - НачалоВыполнения;
		Если ДлительностьВыполнения > МаксимальнаяДлительностьВыполненияИсполняющегоФоновогоЗадания Тогда
			МожноВыполнять = Ложь;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Локальные служебные процедуры и функции

// Формирует и возвращает таблицу имен регламентных заданий с признаком использования.
//
// Возвращаемое значение:
// ТаблицаЗначений - таблица, которую необходимо заполнить
// 	регламентными заданиями и признаком использования.
//
Функция ПолучитьТаблицуИспользованияРегламентныхЗаданий()
	
	ТаблицаИспользования = Новый ТаблицаЗначений;
	ТаблицаИспользования.Колонки.Добавить("РегламентноеЗадание", Новый ОписаниеТипов("Строка"));
	ТаблицаИспользования.Колонки.Добавить("Использование", Новый ОписаниеТипов("Булево"));
	
	// Обязательно для этой подсистемы.
	НоваяСтрока = ТаблицаИспользования.Добавить();
	НоваяСтрока.РегламентноеЗадание = "ПланированиеОбработкиЗаданий";
	НоваяСтрока.Использование       = Истина;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования);
	КонецЦикла;
	
	ОчередьЗаданийПереопределяемый.ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования);
	
	Возврат ТаблицаИспользования;
	
КонецФункции

Функция КоличествоИсполняющихФоновыхЗаданий()
	
	Отбор = Новый Структура("Наименование, Состояние", ПолучитьНаименованиеИсполняющегоФоновогоЗадания(), СостояниеФоновогоЗадания.Активно); 
	ИсполняющиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор); 
	
	КоличествоРаботающихФоновыхЗаданий = ИсполняющиеФоновыеЗадания.Количество();
	
	Возврат КоличествоРаботающихФоновыхЗаданий;
	
КонецФункции

// Рассчитывает необходимое количество исполняющих фоновых заданий
// 
Функция КоличествоИсполняющихФоновыхЗаданийКЗапуску()
	
	КоличествоРаботающихФоновыхЗаданий = КоличествоИсполняющихФоновыхЗаданий();
	
	КоличествоИсполняющихФоновыхЗаданийКЗапуску = 
		Константы.МаксимальноеКоличествоИсполняющихФоновыхЗаданий.Получить() - КоличествоРаботающихФоновыхЗаданий;
	
	Если КоличествоИсполняющихФоновыхЗаданийКЗапуску < 0 Тогда
		КоличествоИсполняющихФоновыхЗаданийКЗапуску = 0;
	КонецЕсли;

	Возврат КоличествоИсполняющихФоновыхЗаданийКЗапуску;
	
КонецФункции

// Запускает заданное количество фоновых заданий 
// 
// Параметры: 
// КоличествоЗапускаемыхФоновыхЗаданий - Число - количество фоновых заданий,
//                                       которых необходимо запустить.
//
Процедура ЗапуститьИсполняющееФоновоеЗадание(КоличествоЗапускаемыхФоновыхЗаданий) 
	
	Для Индекс = 1 По КоличествоЗапускаемыхФоновыхЗаданий Цикл
		Ключ = Новый УникальныйИдентификатор;
		Параметры = Новый Массив;
		Параметры.Добавить(Ключ);
		ФоновыеЗадания.Выполнить("ОчередьЗаданийСлужебный.ОбработатьОчередьЗаданий", Параметры, Ключ, ПолучитьНаименованиеИсполняющегоФоновогоЗадания());
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьНаименованиеИсполняющегоФоновогоЗадания()
	
	Возврат "ИсполняющееФоновоеЗадание_5340185be5b240538bc73d9f18ef8df1";
	
КонецФункции

Процедура ЗаписьКонтроляВыполнения(Знач ИмяСобытия, Знач ЗаписьЗадания, Знач Комментарий = "")
	
	Если Не ПустаяСтрока(Комментарий) Тогда
		Комментарий = Комментарий + Символы.ПС;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Информация, ,
		Строка(ЗаписьЗадания.УникальныйИдентификатор()), Комментарий + ЗаписьЗадания.ИмяМетода + ";" + 
			?(ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(ЗаписьЗадания.Метаданные().ПолноеИмя(),
				ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()),
				Формат(ЗаписьЗадания.ОбластьДанныхВспомогательныеДанные, "ЧН=0; ЧГ="), "-1"));
	
КонецПроцедуры

// Выполняет обработчик задания созданного не на основе шаблона
// 
// Параметры: 
// Псевдоним - Строка - псевдоним метода, который необходимо выполнить.
// Параметры - Массив - параметры передаются в ИмяМетода 
// в порядке расположения элементов массива.
// 
Процедура ВыполнитьОбработчикЗадания(Шаблон, Псевдоним, Параметры)
	
	ИмяМетода = ОчередьЗаданийСлужебныйПовтИсп.СоответствиеИменМетодовПсевдонимам().Получить(ВРег(Псевдоним));
	Если ИмяМетода = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'У метода %1 не зарегистрирован псевдоним для вызова через очередь заданий.'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяМетода);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ОбщегоНазначения.ВыполнитьБезопасно(ИмяМетода, Параметры);
	
КонецПроцедуры

// Возвращает следующую дата выполнения расписания
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания - расписание по которому
//   будет рассчитываться дата
//  ДатаДляПроверки - Дата (ДатаВремя) - минимальная дата на которую может
//   быть запланировано выполнение
//  ДатаНачалаПоследнегоЗапуска - Дата (ДатаВремя) - Дата начала последнего 
//   запуска задания. Если дата задана, то используется для проверки таких 
//   условий как ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня. 
//   Если дата не задана, то считается, что задание не выполнялось ни разу 
//   и проверка этих условий не производится. 
//  ДатаЗавершенияПоследнегоЗапуска - Дата (ДатаВремя) - Дата завершения 
//   последнего запуска задания. Если дата задана, то используется для 
//   проверки условия ПаузаПовтора. Если дата не задана, то считается, что 
//   задание ни разу не завершалось, и проверка этого условия не производится. 
//  МаксимальныйГоризонтПланирования - Число - Максимальное количество секунд
//   относительно ДатаДляПроверки на которое может быть выполнено планирование.
//   Увеличение значения может привести к замедлению расчета на сложных
//   расписаниях
//
Функция СледующаяДатаВыполненияРасписания(Знач Расписание, Знач ДатаДляПроверки, 
	Знач ДатаНачалаПоследнегоЗапуска = Неопределено, Знач ДатаЗавершенияПоследнегоЗапуска = Неопределено, 
	Знач МаксимальныйГоризонтПланирования = Неопределено) Экспорт
	
	Если МаксимальныйГоризонтПланирования = Неопределено Тогда
		МаксимальныйГоризонтПланирования = 366 * 86400 * 10;
	КонецЕсли;
	
	ИсходнаяДатаДляПроверки = ДатаДляПроверки;
	ВремяНачалаПоследнегоЗапуска = '00010101' + (ДатаНачалаПоследнегоЗапуска - НачалоДня(ДатаНачалаПоследнегоЗапуска));
	
	// Границы по датам
	Если ЗначениеЗаполнено(Расписание.ДатаКонца)
		И ДатаДляПроверки > Расписание.ДатаКонца Тогда
		
		// Интервал выполнения по дням закончился
		Возврат '00010101';
	КонецЕсли;
		
	Если ДатаДляПроверки < Расписание.ДатаНачала Тогда
		ДатаДляПроверки = Расписание.ДатаНачала;
	КонецЕсли;
	
	МожноМенятьДень = Истина;
	
	// Учет периодичности
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
		
		// Период недель
		Если Расписание.ПериодНедель > 1
			И (НачалоНедели(ДатаДляПроверки) - НачалоНедели(ДатаНачалаПоследнегоЗапуска)) / (7 * 86400) < Расписание.ПериодНедель Тогда
		
			ДатаДляПроверки = НачалоНедели(ДатаНачалаПоследнегоЗапуска) + 7 * 86400 * Расписание.ПериодНедель;
		КонецЕсли;
		
		// Период дней
		Если Расписание.ПериодПовтораДней = 0 Тогда
			Если НачалоДня(ДатаДляПроверки) <> НачалоДня(ДатаНачалаПоследнегоЗапуска) Тогда
				// Повторения не установлено и задание уже выполнялось
				Возврат '00010101';
			КонецЕсли;
			
			МожноМенятьДень = Ложь;
		КонецЕсли;
		
		Если Расписание.ПериодПовтораДней > 1
			И НачалоДня(ДатаДляПроверки) - НачалоДня(ДатаНачалаПоследнегоЗапуска) < (Расписание.ПериодПовтораДней - 1)* 86400 Тогда
			
			ДатаДляПроверки = НачалоДня(ДатаНачалаПоследнегоЗапуска) + Расписание.ПериодПовтораДней * 86400;
		КонецЕсли;
	КонецЕсли;
	
	// Учет допустимых интервалов запуска
	ПоменятьМесяц = Ложь;
	ПоменятьДень = Ложь;
	Пока Истина Цикл
		
		Если ДатаДляПроверки - ИсходнаяДатаДляПроверки > МаксимальныйГоризонтПланирования Тогда
			// Отложить планирование
			Возврат '00010101';
		КонецЕсли;
		
		Если НЕ МожноМенятьДень
			И (ПоменятьДень ИЛИ ПоменятьМесяц) Тогда
			
			// Повторения не установлено и задание уже выполнялось
			Возврат '00010101';
		КонецЕсли;
		
		// Месяцы
		Пока ПоменятьМесяц
			ИЛИ Расписание.Месяцы.Количество() > 0 
			И Расписание.Месяцы.Найти(Месяц(ДатаДляПроверки)) = Неопределено Цикл
			
			ПоменятьМесяц = Ложь;
			
			// Переход на следующий месяц
			ДатаДляПроверки = НачалоМесяца(ДобавитьМесяц(ДатаДляПроверки, 1));
		КонецЦикла;
		
		// День месяца
		ДнейВМесяце = День(КонецМесяца(ДатаДляПроверки));
		Если Расписание.ДеньВМесяце <> 0 Тогда
			
			ТекущийДень = День(ДатаДляПроверки);
			
			Если Расписание.ДеньВМесяце > 0 
				И (ДнейВМесяце < Расписание.ДеньВМесяце ИЛИ ТекущийДень > Расписание.ДеньВМесяце)
				ИЛИ Расписание.ДеньВМесяце < 0 
				И (ДнейВМесяце < -Расписание.ДеньВМесяце ИЛИ ТекущийДень > ДнейВМесяце - -Расписание.ДеньВМесяце) Тогда
				
				// В этом месяце нет такого числа или оно уже прошло
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце > 0 Тогда
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (Расписание.ДеньВМесяце - 1) * 86400;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце < 0 Тогда
				ДатаДляПроверки = НачалоДня(КонецМесяца(ДатаДляПроверки)) - (-Расписание.ДеньВМесяце -1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели в месяце
		Если Расписание.ДеньНеделиВМесяце <> 0 Тогда
			Если Расписание.ДеньНеделиВМесяце > 0 Тогда
				ДеньНачалаНедели = (Расписание.ДеньНеделиВМесяце - 1) * 7 + 1;
			КонецЕсли;
			Если Расписание.ДеньНеделиВМесяце < 0 Тогда
				ДеньНачалаНедели = ДнейВМесяце - (-Расписание.ДеньНеделиВМесяце) * 7 + 1;
			КонецЕсли;
			
			ДеньКонцаНедели = Мин(ДеньНачалаНедели + 6, ДнейВМесяце);
			
			Если День(ДатаДляПроверки) > ДеньКонцаНедели 
				ИЛИ ДеньНачалаНедели > ДнейВМесяце Тогда
				// В этом месяце нужная неделя уже прошла (или ее не было)
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) < ДеньНачалаНедели Тогда
				Если Расписание.ДеньВМесяце <> 0 Тогда
					
					// День зафиксирован и он не подходит
					ПоменятьМесяц = Истина;
					Продолжить;
				КонецЕсли;
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (ДеньНачалаНедели - 1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели
		Пока ПоменятьДень
			ИЛИ Расписание.ДниНедели.Найти(ДеньНедели(ДатаДляПроверки)) = Неопределено
			И Расписание.ДниНедели.Количество() > 0 Цикл
			
			ПоменятьДень = Ложь;
			
			Если Расписание.ДеньВМесяце <> 0 Тогда
				// День зафиксирован и он не подходит
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) = ДнейВМесяце Тогда
				// Месяц кончился
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если Расписание.ДеньНеделиВМесяце <> 0
				И День(ДатаДляПроверки) = ДеньКонцаНедели Тогда
				
				// Нужная неделя кончилась
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + 86400;
		КонецЦикла;
		Если ПоменятьМесяц Тогда
			Продолжить;
		КонецЕсли;
		
		// Учет времени
		ВремяДляПроверки = '00010101' + (ДатаДляПроверки - НачалоДня(ДатаДляПроверки));
		
		Если Расписание.ДетальныеРасписанияДня.Количество() = 0 Тогда
			ДетальныеРасписания = Новый Массив;
			ДетальныеРасписания.Добавить(Расписание);
		Иначе
			ДетальныеРасписания = Расписание.ДетальныеРасписанияДня;
		КонецЕсли;
		
		Для Индекс = 0 По ДетальныеРасписания.ВГраница() Цикл
			РасписаниеДня = ДетальныеРасписания[Индекс];
			
			// Границы по времени
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяНачала)
				И ВремяДляПроверки < РасписаниеДня.ВремяНачала Тогда
				
				ВремяДляПроверки = РасписаниеДня.ВремяНачала;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца)
				И ВремяДляПроверки > РасписаниеДня.ВремяКонца Тогда
				
				Если Индекс < ДетальныеРасписания.ВГраница() Тогда
					// Есть еще расписания дня
					Продолжить;
				КонецЕсли;
				
				// В этом дне подходящее время уже прошло
				ПоменятьДень = Истина;
				Прервать;
			КонецЕсли;
			
			// Период повтора в течении дня
			Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
				
				Если РасписаниеДня.ПериодПовтораВТечениеДня = 0
					И НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) И ВремяНачалаПоследнегоЗапуска >= РасписаниеДня.ВремяНачала)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И ВремяНачалаПоследнегоЗапуска <= РасписаниеДня.ВремяКонца) Тогда
					
					// В этом интервале (расписании дня) задание уже выполнялось и повторы не установлены
					Если Индекс < ДетальныеРасписания.ВГраница() Тогда
						Продолжить;
					КонецЕсли;
					
					ПоменятьДень = Истина;
					Прервать;
				КонецЕсли;
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяНачалаПоследнегоЗапуска < РасписаниеДня.ПериодПовтораВТечениеДня Тогда
					
					НовоеВремяДляПроверки = ВремяНачалаПоследнегоЗапуска + РасписаниеДня.ПериодПовтораВТечениеДня;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
				
			КонецЕсли;
			
			// Пауза
			Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) 
				И ЗначениеЗаполнено(РасписаниеДня.ПаузаПовтора) Тогда
				
				ВремяЗавершенияПоследнегоЗапуска = '00010101' + (ДатаЗавершенияПоследнегоЗапуска - НачалоДня(ДатаЗавершенияПоследнегоЗапуска));
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяЗавершенияПоследнегоЗапуска < РасписаниеДня.ПаузаПовтора Тогда
					
					НовоеВремяДляПроверки = ВремяЗавершенияПоследнегоЗапуска + РасписаниеДня.ПаузаПовтора;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
			КонецЕсли;
			
			// Нашли подходящее время
			Прервать;
			
		КонецЦикла;
		
		Если ПоменятьДень Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Расписание.ВремяЗавершения)
			И ВремяДляПроверки > Расписание.ВремяЗавершения Тогда
			// В этом дне выполнять поздно
			ПоменятьДень = Истина;
			Продолжить;
		КонецЕсли;
		
		ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + (ВремяДляПроверки - НачалоДня(ВремяДляПроверки));
		
		Возврат ДатаДляПроверки;
		
	КонецЦикла;
	
КонецФункции

Процедура ЗапланироватьЗадание(Знач Выборка)
	
	Если ЗначениеЗаполнено(Выборка.ЧасовойПояс) Тогда
		ЧасовойПояс = Выборка.ЧасовойПояс;
	Иначе
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		
		Если Выборка.ОбластьДанных <> -1 Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, Выборка.ОбластьДанных);
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(Выборка.Идентификатор.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Идентификатор);
		Блокировка.Заблокировать();
		
		Если НЕ ОбщегоНазначения.СсылкаСуществует(Выборка.Идентификатор) Тогда
			Блокировка.Заблокировать();
			РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
		
		Задание = Выборка.Идентификатор.ПолучитьОбъект();
		
		// Если состояние задания Выполняется, но данные не заблокированы для редактирования - значит оно уже не выполняется
		Если Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Выполняется Тогда
			ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено с ошибками'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Выборка.Идентификатор, 
				НСтр("ru = 'Исполняющее задание было принудительно завершено'"));
		КонецЕсли;
		
		Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(Задание.Метаданные().ПолноеИмя(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			Если ЗначениеЗаполнено(Задание.Шаблон)
				И Выборка.Шаблон = Неопределено Тогда
				
				ШаблонСообщения = НСтр("ru = 'На найден шаблон задания очереди  %1'", 
					Метаданные.ОсновнойЯзык.КодЯзыка);
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Задание.Шаблон);
				
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий. Планирование'", 
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстСообщения);
				
				ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
				РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
				ОтменитьТранзакцию();
				Возврат;
				
			КонецЕсли;
			
		КонецЕсли;
			
		Если (Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Выполняется 
			Или Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения)
			И Задание.НомерПопытки < Выборка.КоличествоПовторовПриАварийномЗавершении Тогда // Попытка повторного запуска
			
			Если ЗначениеЗаполнено(Задание.ДатаЗавершенияПоследнегоЗапуска) Тогда
				ТочкаОтсчетаПерезапуска = Задание.ДатаЗавершенияПоследнегоЗапуска;
			Иначе
				ТочкаОтсчетаПерезапуска = Задание.ДатаНачалаПоследнегоЗапуска;
			КонецЕсли;
			
			Задание.ЗапланированныйМоментЗапуска = ТочкаОтсчетаПерезапуска + Выборка.ИнтервалПовтораПриАварийномЗавершении;
			Задание.НомерПопытки                 = Задание.НомерПопытки + 1;
			Задание.СостояниеЗадания             = Перечисления.СостоянияЗаданий.Запланировано;
			Задание.ИсполняющееФоновоеЗадание    = Неопределено;
			Задание.Записать();
			
		Иначе
			Расписание = Выборка.Расписание.Получить();
			Если Расписание <> Неопределено Тогда
				
				Задание.ЗапланированныйМоментЗапуска = ПолучитьЗапланированныйМоментЗапускаЗадания(
					Расписание, ЧасовойПояс, Задание.ДатаНачалаПоследнегоЗапуска, Задание.ДатаЗавершенияПоследнегоЗапуска);
				Задание.НомерПопытки = 0;
				Если ЗначениеЗаполнено(Задание.ЗапланированныйМоментЗапуска) Тогда
					Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Запланировано;
				Иначе
					Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.НеАктивно;
				КонецЕсли;
				Задание.ИсполняющееФоновоеЗадание = Неопределено;
				Задание.Записать();
				
			Иначе // Нет расписания
				
				Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() И ОбщегоНазначенияПовтИсп.ЭтоРазделенныйОбъектМетаданных(
							Задание.Метаданные().ПолноеИмя(),
							ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()
						) Тогда
					Если ЗначениеЗаполнено(Задание.Шаблон) Тогда // Задание по шаблону без расписания
						
						ШаблонСообщения = НСтр("ru = 'Для шаблон заданий очереди  %1 не найдено расписание'", 
							Метаданные.ОсновнойЯзык.КодЯзыка);
						ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Задание.Шаблон);
						ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь заданий. Планирование'", 
							ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), 
							УровеньЖурналаРегистрации.Ошибка,
							,
							,
							ТекстСообщения);
						
						ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
						ОтменитьТранзакцию();
						РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
						Возврат;
						
					КонецЕсли;
				КонецЕсли;
				
				// Разовое задание
				Задание.ОбменДанными.Загрузка = Истина;
				Задание.Удалить();
				
			КонецЕсли;
		КонецЕсли;
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ЗафиксироватьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Выборка.Идентификатор);
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

Процедура ВыполнитьЗаданиеОчереди(Знач Ссылка, Знач ИсполняющееФоновоеЗадание, 
		Знач Шаблон, Знач ИмяМетода)
	
	ОбластьДанных = Неопределено;
	Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() Тогда
		МодульОчередьЗаданийСлужебныйРазделениеДанных = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("ОчередьЗаданийСлужебныйРазделениеДанных");
		ПереопределеннаяОбластьДанных = МодульОчередьЗаданийСлужебныйРазделениеДанных.ОпределитьОбластьДанныхДляЗадания(Ссылка);
		Если ПереопределеннаяОбластьДанных <> Неопределено Тогда
			ОбластьДанных = ПереопределеннаяОбластьДанных;
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьДанных = Неопределено Тогда
		ОбластьДанных = -1;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		
		Если ОбластьДанных <> -1 Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьДанных);
		КонецЕсли;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить(Ссылка.Метаданные().ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("Ссылка", Ссылка);
		Блокировка.Заблокировать();
		
		Задание = Ссылка.ПолучитьОбъект();
		
		Если Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Запланировано
			И Задание.Использование
			И Задание.ЗапланированныйМоментЗапуска <= ТекущаяУниверсальнаяДата() Тогда 
			
			Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Выполняется;
			Задание.ИсполняющееФоновоеЗадание = ИсполняющееФоновоеЗадание.УникальныйИдентификатор;
			Задание.ДатаНачалаПоследнегоЗапуска = ТекущаяУниверсальнаяДата();
			Задание.ДатаЗавершенияПоследнегоЗапуска = Неопределено;
			Задание.Записать();
			
			ЗафиксироватьТранзакцию();
			
		Иначе
			
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
			ЗафиксироватьТранзакцию();
			Возврат;
			
		КонецЕсли;
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Выполнение задания
	ВыполненоУспешно = Ложь;
	ИнформацияОбОшибкеВыполненияЗадания = Неопределено;
	Попытка
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Старт'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка);
		
		Если ЗначениеЗаполнено(Шаблон) Тогда
			ОбщегоНазначения.ВыполнитьБезопасно(ИмяМетода);
		Иначе
			ВыполнитьОбработчикЗадания(Шаблон, ИмяМетода, Задание.Параметры.Получить());
		КонецЕсли;
		
		ВыполненоУспешно = Истина;
		
		Если ТранзакцияАктивна() Тогда
			
			Пока ТранзакцияАктивна() Цикл
				ОтменитьТранзакцию();
			КонецЦикла;
			
			ШаблонСообщения = НСтр("ru = 'По завершении выполнения обработчика %1 не была закрыта транзакция'", Метаданные.ОсновнойЯзык.КодЯзыка);
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Задание.ИмяМетода);
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий. Выполнение'", 
				ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, 
				,
				ИсполняющееФоновоеЗадание, 
				ТекстСообщения);
			
		КонецЕсли;
		
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено успешно'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка);
		
	Исключение
		
		Пока ТранзакцияАктивна() Цикл
			ОтменитьТранзакцию();
		КонецЦикла;
		
		ЗаписьКонтроляВыполнения(НСтр("ru = 'Очередь регламентных заданий.Завершено с ошибками'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), Ссылка, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Очередь регламентных заданий. Выполнение'", 
			ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, 
			,
			ИсполняющееФоновоеЗадание, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())); 
			
		ИнформацияОбОшибкеВыполненияЗадания = ИнформацияОбОшибке();
		
	КонецПопытки;
		
	Если НЕ ВыполненоУспешно Тогда
		// Вызов обработчиков ошибок
		ОбработчикОшибок = 
			ОчередьЗаданийСлужебныйПовтИсп.СоответствиеОбработчиковОшибокПсевдонимам().Получить(ВРег(ИмяМетода));
			
		Если ОбработчикОшибок <> Неопределено Тогда
				
			ПараметрыЗадания = Новый Структура;
			ПараметрыЗадания.Вставить("Параметры", Задание.Параметры.Получить());
			ПараметрыЗадания.Вставить("НомерПопытки", Задание.НомерПопытки);
			ПараметрыЗадания.Вставить("КоличествоПовторовПриАварийномЗавершении", Задание.КоличествоПовторовПриАварийномЗавершении);
			ПараметрыЗадания.Вставить("ДатаНачалаПоследнегоЗапуска", Задание.ДатаНачалаПоследнегоЗапуска);
			
			ПараметрыОбработчикаОшибок = Новый Массив;
			ПараметрыОбработчикаОшибок.Добавить(ПараметрыЗадания);
			ПараметрыОбработчикаОшибок.Добавить(ИнформацияОбОшибкеВыполненияЗадания);
			
			Попытка
				ОбщегоНазначения.ВыполнитьБезопасно(ОбработчикОшибок, ПараметрыОбработчикаОшибок);
			Исключение
				Пока ТранзакцияАктивна() Цикл
					ОтменитьТранзакцию();
				КонецЦикла;
				
				ШаблонКомментария = НСтр("ru = 'Ошибка при выполнении обработчика ошибок
					|Псевдоним метода: %1
					|Метод обработчика ошибок: %2
					|По причине:
					|%3'");
				ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ШаблонКомментария,
					ИмяМетода,
					ОбработчикОшибок,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
					
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Очередь регламентных заданий. Ошибка обработчика ошибок'", 
						ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстКомментария);
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		
		Если ОбщегоНазначения.СсылкаСуществует(Ссылка) Тогда // иначе - задание могло быть удалено внутри обработчика
			
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить(Ссылка.Метаданные().ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Ссылка);
			Блокировка.Заблокировать();
			
			Задание = Ссылка.ПолучитьОбъект();
			Задание.ДатаЗавершенияПоследнегоЗапуска = ТекущаяУниверсальнаяДата();
			
			Если ВыполненоУспешно Тогда
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.Завершено;
			Иначе
				Задание.СостояниеЗадания = Перечисления.СостоянияЗаданий.ОшибкаВыполнения;
			КонецЕсли;
			Задание.Записать();
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "ОчередьЗаданийСлужебный.УстановитьИспользованиеРегламентныхЗаданий";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.Приоритет = 50;
	Обработчик.МонопольныйРежим = Ложь;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.9";
	Обработчик.Процедура = "ОчередьЗаданийСлужебный.ПеренестиЗаданияВОчередиВНеразделенныеДанные";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 80;
	Обработчик.МонопольныйРежим = Истина;
	
КонецПроцедуры

// Отключает регламентные задания задания используемые только в локальном режиме
// и включает используемые только в модели сервиса.
//
Процедура УстановитьИспользованиеРегламентныхЗаданий() Экспорт
	
	ИнвертироватьИспользование = Не ОбщегоНазначенияПовтИсп.РазделениеВключено();
	
	ТаблицаИспользованияРегламентныхЗаданий = ПолучитьТаблицуИспользованияРегламентныхЗаданий();
		
	Для Каждого Строка Из ТаблицаИспользованияРегламентныхЗаданий Цикл
		
		Отбор = Новый Структура("Метаданные", Метаданные.РегламентныеЗадания[Строка.РегламентноеЗадание]);
		НайденныеРегламентныеЗадания = РегламентныеЗадания.ПолучитьРегламентныеЗадания(Отбор);
		
		Для Каждого РегламентноеЗадание Из НайденныеРегламентныеЗадания Цикл
			Если ИнвертироватьИспользование Тогда
				ТребуемоеИспользование = Не Строка.Использование;
			Иначе
				ТребуемоеИспользование = Строка.Использование;
			КонецЕсли;
			
			Если РегламентноеЗадание.Использование <> ТребуемоеИспользование Тогда
				РегламентноеЗадание.Использование = ТребуемоеИспользование;
				РегламентноеЗадание.Записать();
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Переносит задания из РС ОчередьЗаданий в справочник ОчередьЗаданий
Процедура ПеренестиЗаданияВОчередиВНеразделенныеДанные() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных();
		БлокировкаСправочника = Блокировка.Добавить("Справочник.ОчередьЗаданий");
		БлокировкаСправочника.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	УдалитьОчередьЗаданий.Использование,
		|	УдалитьОчередьЗаданий.ЗапланированныйМоментЗапуска,
		|	УдалитьОчередьЗаданий.СостояниеЗадания,
		|	УдалитьОчередьЗаданий.ИсполняющееФоновоеЗадание,
		|	УдалитьОчередьЗаданий.ЭксклюзивноеВыполнение,
		|	УдалитьОчередьЗаданий.Шаблон,
		|	УдалитьОчередьЗаданий.НомерПопытки,
		|	УдалитьОчередьЗаданий.УдалитьРегламентноеЗадание,
		|	УдалитьОчередьЗаданий.ИмяМетода,
		|	УдалитьОчередьЗаданий.Параметры,
		|	УдалитьОчередьЗаданий.ДатаНачалаПоследнегоЗапуска,
		|	УдалитьОчередьЗаданий.Ключ,
		|	УдалитьОчередьЗаданий.ИнтервалПовтораПриАварийномЗавершении,
		|	УдалитьОчередьЗаданий.Расписание,
		|	УдалитьОчередьЗаданий.КоличествоПовторовПриАварийномЗавершении,
		|	УдалитьОчередьЗаданий.Идентификатор
		|ИЗ
		|	РегистрСведений.УдалитьОчередьЗаданий КАК УдалитьОчередьЗаданий
		|ГДЕ
		|	УдалитьОчередьЗаданий.ОбластьДанных = -1";
		Запрос = Новый Запрос(ТекстЗапроса);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СсылкаЗадания = Справочники.ОчередьЗаданий.ПолучитьСсылку(
				Новый УникальныйИдентификатор(Выборка.Идентификатор));
			
			Если ОбщегоНазначения.СсылкаСуществует(СсылкаЗадания) Тогда
				НовоеЗадание = СсылкаЗадания.ПолучитьОбъект();
			Иначе
				НовоеЗадание = Справочники.ОчередьЗаданий.СоздатьЭлемент();
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(НовоеЗадание, Выборка);
			НовоеЗадание.Записать();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры